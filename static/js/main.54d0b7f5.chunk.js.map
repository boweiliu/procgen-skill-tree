{"version":3,"sources":["data/GameState.ts","lib/util/misc.ts","game/Neighbors.ts","components/NodeDetail.tsx","contexts.ts","components/PixiWrapperComponent.tsx","lib/util/epsilon_math.ts","lib/util/geometry/vector2.ts","lib/util/data_structures/hash.ts","lib/pixi/pixify.ts","game/OnAllocation.ts","game/ComputeState.ts","pixi/components/PointNodeComponent.ts","pixi/components/ChunkComponent.ts","game/WorldGenStateFactory.ts","lib/util/fpsTracker.ts","pixi/components/FpsComponent.ts","lib/util/updaterGenerator.ts","pixi/components/ZLevelComponent.ts","pixi/components/ReticleComponent.ts","lib/util/batchify.ts","pixi/components/RootComponent.ts","pixi/textures/PointNodeTexture.ts","pixi/PixiReactBridge.ts","game/GameStateFactory.ts","components/PixiComponent.tsx","components/QuestProgress.tsx","components/Sidebar.tsx","components/TabContent.tsx","components/Tabs.tsx","components/DebugTab.tsx","game/QuestFactory.ts","App.tsx","serviceWorker.ts","index.tsx","lib/util/random.ts"],"names":["ResourceNontrivialType","ChunkGenConstants","CHUNK_HALF_DIM","CHUNK_DIM","DROP_NODES_CHANCE","ResourceModifier","ResourceType","Nothing","PointNodeRef","args","z","chunkCoord","pointNodeCoord","pointNodeId","this","toString","ChunkRef","chunkId","ResourceTypeAndModifier","type","modifier","Util","list","fn","lowestT","lowestValue","item","value","obj","highestT","highestValue","low","high","Math","floor","random","array","key","sort","a","b","str","mapObj","re","RegExp","Object","keys","join","replace","matched","toLowerCase","func","timeoutId","waitMilliseconds","options","isImmediate","result","doLater","undefined","apply","shouldCallNow","clearTimeout","setTimeout","d","monthName","getMonth","getDate","getHours","substr","getMinutes","getSeconds","arr","concat","string","length","intersperse","character","repeat","assertOnlyCalledOnceData","assertOnlyCalledOnce","id","k","Error","stacktrace","stack","Direction","Lazy","factory","_wasConstructed","_value","_factory","multiplyColor","color1","color2","reds","blues","greens","out","round","enumKeys","enm","getNeighbors","selfPointNodeRef","worldGen","neighborsMap","neighbors","zLevel","zLevels","myChunk","chunks","get","x","addX","chunk","withX","nbor","pointNodes","right","left","y","addY","withY","down","up","getNeighborsMap","it","push","canAllocate","allocatedPointNodeSet","availableSp","contains","NodeDetail","selectedPointNode","pointNodeGen","isAllocated","canBeAllocated","nodeDescription","resourceType","resourceAmount","resourceModifier","UseGameStateContext","React","createContext","PixiWrapperComponent","props","application","windowState","container","useRef","useContext","gameState","gameStateUpdaters","fireBatchedSetGameState","useEffect","i","current","childNodes","removeChild","appendChild","app","view","rerender","fireBatch","fireBatchedSetWindowState","isSecondConstructorCall","updaters","ref","EPSILON","Vector2","propsOrX","_x","_y","p","abs","max","dx","dy","sqrt","newY","about","amount","origin","angle","PI","cos","sin","other","__type","trans","scale","newX","t","console","error","add","tx","ty","lerp","highX","highY","lowX","lowY","RandRange","hasOwnProperty","JSON","stringify","Zero","One","HashSet","initialValues","_values","HashMap","put","remove","values","n","clone","size","hash","KeyedHashMap","_kvalues","map","s","hashCode","reduce","pv","cv","h","imul","charCodeAt","PixiPointFrom","Pixi","afterMaybeSpendingSp","prev","prevGameState","activeQuest","batchesSinceQuestStart","computePlayerResourceAmounts","amounts","playerResourceNodesAggregated","playerSave","allocatedPointNodeHistory","pointNodeRef","resourceTypeAndModifier","Flat","Increased0","AfterIncreased0","Increased1","AfterIncreased1","playerResourceAmounts","PointNodeComponent","staleProps","state","sprite","centerSprite","justTriedToAllocate","justSpentSp","justFailedToAllocate","numClicks","sortableChildren","pointNodeTexture","anchor","zIndex","addChild","interactive","buttonMode","hitArea","RenderedChunkConstants","NODE_HITAREA_PX","renderSelf","didMount","tint","centerTint","position","isSelected","baseColor","Mana0","Mana1","Mana2","prevProps","shouldUpdate","updateSelf","addListener","event","playerUI","enqueueUpdate","nextSet","nextHistory","doTryAllocate","next","computed","activeTab","SPACING_PX","CHUNK_SPACING_PX","NODE_SIZE_PX","NODE_ROUNDED_PX","ChunkComponent","children","chunkGen","entries","selfChunkRef","childProps","delta","multiply","allocatedPointNodeSubset","childComponent","update","ZLevelGenFactory","config","chunkGenFactory","ChunkGenFactory","squirrel3","seed","startingChunks","j","location","create","pointNodeGenFactory","PointNodeGenFactory","droppedNodes","INTMAX32","loc","randomFloat","equals","FpsTracker","frameTimestampsInTicks","frameTimestampsInTime","ticksSinceLastUpdate","lastFrameTime","logRowsToKeep","slice","Date","getTime","ticksDiff","framesPerTick","timeDiff","framesPerMilli","getFps","toFixed","getUps","FpsComponent","fontFamily","fontSize","tick","text","getFpsString","getUpsString","appSize","updaterGenerator2Helper","dataObject","dataUpdater","forEach","newValueOrCallback","oldData","wholeData","updaterGenerator2","setState","stateCallbackFunction","ZLevelComponent","zLevelGen","chunkRef","filter","didUpdate","ReticleComponent","lineStyle","drawCircle","batchifySetState","batch","arg","log","batchSize","fired","thisBatch","valueOrCallback","RootComponent","stateUpdaters","fireStateUpdaters","fixedCameraStage","actionStage","backdropStage","keyboard","fpsTracker","reticle","backdrop","renderer","g","beginFill","drawRoundedRect","generateTexture","NEAREST","generatePointNodeTexture","playerIntents","decreaseZLevel","justDown","justUp","increaseZLevel","panLeft","panRight","panUp","panDown","batchedSetState","drawRect","prevSize","nextSize","width","height","whole","PixiReactBridge","onTick","originalAppSize","antialias","transparent","resolution","window","devicePixelRatio","autoDensity","powerPreference","backgroundColor","ticker","destroy","texture","baseTexture","baseGameLoop","bind","curr","min","Infinity","appSizeFromWindowSize","innerWidth","innerHeight","stage","resize","GameStateFactory","mySeed","firstId","0","initialApplication","PixiComponent","useState","orientation","setWindowState","useMemo","batchedSetWindowState","setApplication","onresize","old","onClick","newGameState","pause","originalSetGameState","QuestProgress","remainingPoints","createQuestCb","numBatches","isQuestComplete","className","classnames","good","alert","Sidebar","TabContent","showContent","hidden","Tabs","labels","onChange","label","Tab","active","DebugTab","history","setHistory","reverse","QuestFactory","description","browser","UAParser","getBrowser","forceRotate","name","tabLabels","initialGameState","App","setGameState","batchedSetGameState","tabViews","useCallback","createQuest","Provider","getUpdater","component","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.54d0b7f5.chunk.js","sourcesContent":["import { HashMap, HashSet, KeyedHashMap } from \"../lib/util/data_structures/hash\"\nimport { Vector2 } from \"../lib/util/geometry/vector2\"\n\n/**\n * Data owned by the master \"App\" component, to be made available as props to ALL subcomponents (both pixi and react); react uses context providers to make this easier\n * 1. world generation data, stuff that was computed off of the random seed and is stored so we can do logic off of it,\n *   but can be deleted/recomputed any time.\n *   May or may not be persisted to disk - unimportant apart from the random seed.\n * 2. data about player activity in the game e.g. which nodes were allocated, what quest stage they are on\n *   Must be persisted to disk - this is essentially the player's \"save file\"\n * 3. data about player activity that only influences the UI, e.g. which node was selected, but affects UI across\n *   very far away pixi/react components.\n *   Should be persisted to disk - will help the player \"remember their place\" in the game, but not a big deal if lost.\n * 4. data about the window display - should never be persisted to disk.\n * 5. data that is computed from other data - no need to persist to disk.\n * \n * Does NOT include UI data which is only relevant to a small part of the component hierarchy - e.g. how many seconds since last tap.\n * That data should belong in state owned by subcomponents.\n */\nexport type GameState = {\n  worldGen: WorldGenState,\n  playerSave: PlayerSaveState,\n  playerUI: PlayerUIState,\n  computed: ComputedState\n}\n\nexport type WorldGenState = {\n  seed: number,\n  zLevels: {[z: number]: ZLevelGen}\n}\n\nexport type ZLevelGen = {\n  id: number,\n  chunks: KeyedHashMap<Vector2, ChunkGen>\n}\n\nexport type ChunkGen = {\n  id: number,\n  pointNodes: KeyedHashMap<Vector2, PointNodeGen>\n}\n\nexport class ChunkGenConstants {\n  public static CHUNK_DIM = 9; // each chunk is a DIM x DIM grid of nodes, centered on a single node\n  public static CHUNK_HALF_DIM = (ChunkGenConstants.CHUNK_DIM - 1) / 2;\n  public static DROP_NODES_CHANCE = 0.3; // before generating edges, how many of the nodes to throw out\n}\n\nexport type PointNodeGen = {\n  id: number;\n\n  // more data to be generated here - size, color, etc.\n  resourceType: ResourceType;\n  resourceModifier: ResourceModifier;\n  resourceAmount: number;\n}\n\nexport enum ResourceNontrivialType {\n  Mana0 = \"Mana0\",\n  Mana1 = \"Mana1\",\n  Mana2 = \"Mana2\",\n}\n\nexport type ResourceType = \"Nothing\" | ResourceNontrivialType;\n// eslint-disable-next-line\nexport const ResourceType = { Nothing: \"Nothing\", ...ResourceNontrivialType };\n\nexport enum ResourceModifier {\n  Flat = \"Flat\",\n  Increased0 = \"% increased\",\n  AfterIncreased0 = \"added after % increased\",\n  Increased1 = \"% increased multiplier\",\n  AfterIncreased1 = \"added after % increased multiplier\"\n}\n\nexport type PlayerSaveState = {\n  availableSp: number,\n  activeQuest: Quest | undefined,\n  batchesSinceQuestStart: number,\n  // TODO(bowei): save the seed in here as well?\n\n  // selectedPointNodeHistory: PointNodeRef[],\n  // justAllocated: PointNodeRef | undefined,\n  allocatedPointNodeSet: HashSet<PointNodeRef>,\n  // history[-1] == most recent, histoery[0] == oldest\n  allocatedPointNodeHistory: PointNodeRef[],\n}\n\nexport type Quest = {\n  description: string | undefined,\n  resourceType: ResourceType,\n  resourceAmount: number,\n}\n\nexport type PlayerUIState = {\n  selectedPointNode: PointNodeRef | undefined,\n  activeTab: number,\n}\n\nexport class PointNodeRef {\n  public z: number;\n  public chunkCoord: Vector2;\n  public pointNodeCoord: Vector2;\n  public pointNodeId: number;\n\n  constructor(args: { z: number, chunkCoord: Vector2, pointNodeCoord: Vector2, pointNodeId: number }) {\n    this.z = args.z;\n    this.chunkCoord = args.chunkCoord;\n    this.pointNodeCoord = args.pointNodeCoord;\n    this.pointNodeId = args.pointNodeId;\n  }\n\n  public hash(): string {\n    return this.pointNodeId.toString() + this.z.toString() + this.chunkCoord.toString() + this.pointNodeCoord.toString();\n  }\n}\n\nexport class ChunkRef {\n  public z: number;\n  public chunkCoord: Vector2;\n  public chunkId: number;\n\n  constructor(args: { z: number, chunkCoord: Vector2, chunkId: number }) {\n    this.z = args.z;\n    this.chunkCoord = args.chunkCoord;\n    this.chunkId = args.chunkId;\n  }\n\n  public hash(): string {\n    return this.chunkId.toString() + this.z.toString() + this.chunkCoord.toString();\n  }\n}\n\n/**\n * current window settings -- allows for dynamic resizing and also rotation on mobile web\n */\nexport type WindowState = {\n  orientation: \"original\" | \"rotated\", // rotated === we are forcing landscape-in-portrait\n  innerWidth: number,\n  innerHeight: number,\n}\n\nexport type ComputedState = {\n  playerResourceAmounts?: { [k in ResourceType]: number }\n  playerResourceNodesAggregated?: HashMap<ResourceTypeAndModifier, number>\n}\n\n// export type ResourceTypeAndModifier = [ResourceType.Nothing] | ([ResourceType, ResourceModifier]);\nexport class ResourceTypeAndModifier {\n  public type: ResourceNontrivialType;\n  public modifier: ResourceModifier;\n\n  constructor(args: { type: ResourceNontrivialType, modifier: ResourceModifier}) {\n    this.type = args.type;\n    this.modifier = args.modifier;\n  }\n\n  public hash(): string {\n    return this.type.toString() + ',' + this.modifier.toString();\n  }\n}","let lastUsedId = 0;\n\nexport const getUniqueID = () => {\n  return lastUsedId++;\n};\n\nexport class Util {\n  static MinBy<T>(list: T[], fn: (T: T) => number): T | null {\n    let lowestT: T | null = null;\n    let lowestValue: number | null = null;\n\n    for (const item of list) {\n      const value = fn(item);\n\n      if (lowestValue === null || value < lowestValue) {\n        lowestT = item;\n        lowestValue = value;\n      }\n    }\n\n    return lowestT;\n  }\n\n  static MinByAndValue<T>(list: T[], fn: (T: T) => number): { obj: T, value: number } | null {\n    let lowestT: T | null = null;\n    let lowestValue: number | null = null;\n\n    for (const item of list) {\n      const value = fn(item);\n\n      if (lowestValue === null || value < lowestValue) {\n        lowestT = item;\n        lowestValue = value;\n      }\n    }\n\n    return lowestT === null || lowestValue === null ? null : { obj: lowestT, value: lowestValue };\n  }\n\n  static MaxBy<T>(list: T[], fn: (T: T) => number): T | null {\n    let highestT: T | null = null;\n    let highestValue: number | null = null;\n\n    for (const item of list) {\n      const value = fn(item);\n\n      if (highestValue === null || value > highestValue) {\n        highestT = item;\n        highestValue = value;\n      }\n    }\n\n    return highestT;\n  }\n\n  static RandRange(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low) + low);\n  }\n\n  public static SortByKey<T>(array: T[], key: (x: T) => number): T[] {\n    return array.sort((a, b) => {\n      return key(a) - key(b)\n    });\n  }\n\n  public static ReplaceAll(\n    str: string,\n    mapObj: { [key: string]: string }\n  ): string {\n    const re = new RegExp(Object.keys(mapObj).join('|'), 'gi')\n\n    return str.replace(re, matched => {\n      return mapObj[matched.toLowerCase()]\n    });\n  }\n\n  public static Debounce<F extends (...args: any[]) => void>(\n    func: F,\n    waitMilliseconds = 50,\n    options = {\n      isImmediate: false,\n    }\n  ): F {\n    let timeoutId: any; // types are different on node vs client, so we have to use any.\n\n    const result = (...args: any[]) => {\n      const doLater = () => {\n        timeoutId = undefined;\n        if (!options.isImmediate) {\n          func.apply(this, args);\n        }\n      }\n\n      const shouldCallNow = options.isImmediate && timeoutId === undefined;\n\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(doLater, waitMilliseconds);\n\n      if (shouldCallNow) {\n        func.apply(this, args);\n      }\n    }\n\n    return result as any;\n  }\n\n  public static FormatDate(d: Date): string {\n    const monthName = [\n      'Jan',\n      'Feb',\n      'Mar',\n      'Apr',\n      'May',\n      'Jun',\n      'Jul',\n      'Aug',\n      'Sep',\n      'Oct',\n      'Nov',\n      'Dec',\n    ][d.getMonth()]\n\n    return `${monthName} ${d.getDate()}, ${('00' + d.getHours()).substr(-2)}:${(\n      '00' + d.getMinutes()\n    ).substr(-2)}:${('00' + d.getSeconds()).substr(-2)}`;\n  }\n\n  public static FlattenByOne<T>(arr: T[][]): T[] {\n    let result: T[] = []\n\n    for (const obj of arr) {\n      result = result.concat(obj)\n    }\n\n    return result\n  }\n\n  public static PadString(string: string, length: number, intersperse = \"\", character = \" \") {\n    return string + intersperse + character.repeat(length - string.length);\n  }\n}\n\n/**\n * A deep readonly type - given an object type, all subobjects and their subobjects are also marked as readonly.\n */\nexport type Const<T> = T extends Function ? T : {\n  readonly [P in keyof T]: T[P] extends { [k: string]: any } ? Const<T[P]> : T[P];\n}\n\nconst assertOnlyCalledOnceData: { [k: string]: [string, number] } = {};\n\n/**\n * Asserts that a function is not called more than twice. Useful for debugging react lifecycle which may be creating more objects than you realize, impacting performance.\n * @param id identifier\n */\nexport function assertOnlyCalledOnce(id: string | number) {\n  let k = id.toString();\n  if (assertOnlyCalledOnceData[k] !== undefined) {\n    if (assertOnlyCalledOnceData[k][1] === 1) {\n      assertOnlyCalledOnceData[k][1] = 2;\n    } else {\n      throw new Error(\"Error, called more than twice with same id: \" + k + \" , callback the first time was : \" + assertOnlyCalledOnceData[k]);\n    }\n  } else {\n    const stacktrace = new Error().stack!\n    assertOnlyCalledOnceData[k] = [stacktrace, 1];\n  }\n}\n\n/**\n * Class representing a value which is only computed when used.\n * \n * Usage: const lazy = new Lazy(() => thingThatReturnsSomething()).\n * Then thingThatReturnsSomething() will only get called on the first time lazy.get() is called.\n * On the second and subsequent times, lazy.get() will return the same object - the factory method is not called again.\n */\nexport class Lazy<T> {\n  private _wasConstructed: boolean = false;\n  private _value: T | undefined = undefined;\n  private _factory: () => T\n\n  constructor(factory: () => T) {\n    this._factory = factory;\n  }\n  public get(): T {\n    // T might have undefined as a valid value\n    if (this._value !== undefined || this._wasConstructed === true) {\n      return this._value!;\n    } else {\n      this._value = this._factory();\n      this._wasConstructed = true;\n      return this._value;\n    }\n  }\n  // public async getAsync(): Promise<T> {\n  //   if (this._value !== undefined || this._wasConstructed === true) {\n  //     return Promise.resolve(this._value!);\n  //   } else {\n  //     return new Promise<T>((resolve, reject) => {\n  //       this._value = this._factory();\n  //       this._wasConstructed = true;\n  //       resolve(this._value);\n  //     });\n  //   }\n  // }\n}\n\n/**\n * Multiplies colors (0xFFFFFF === 1). use for applying tints manually.\n * @param color1 A base color\n * @param color2 A tint\n */\nexport function multiplyColor(color1: number, color2: number): number {\n  let reds = [color1 & 0xFF0000, color2 & 0xFF0000];\n  let blues = [color1 & 0x0000FF, color2 & 0x0000FF];\n  let greens = [color1 & 0x00FF00, color2 & 0x00FF00];\n  let out = Math.round(reds[0] / (0x010000) * reds[1] / (0xFFFFFF)) * 0x010000;\n  out += Math.round(greens[0] / 0x000100 * greens[1] / 0x00FF00) * 0x000100;\n  out += Math.round(blues[0] * blues[1] / 0x0000FF);\n  return out;\n}\n\n\nexport function enumKeys<T extends string>(enm: { [key in T]: T }) : T[] {\n  return Object.keys(enm) as T[];\n}\n\n// export function enumKeys<T extends string>(enm: { [key: string]: string }) : T[] {\n//   return Object.keys(enm) as T[];\n// }","import { HashSet } from \"../lib/util/data_structures/hash\";\nimport { enumKeys } from \"../lib/util/misc\";\nimport { ChunkGenConstants, PointNodeRef, WorldGenState } from \"../data/GameState\";\n\nenum Direction {\n  up = 'up',\n  down = 'down',\n  left = 'left',\n  right = 'right',\n}\n\ntype NeighborsMap = { [k in Direction]?: PointNodeRef | undefined }\n\nexport function getNeighbors(selfPointNodeRef: PointNodeRef, worldGen: WorldGenState): PointNodeRef[] {\n  let neighborsMap = getNeighborsMap(selfPointNodeRef, worldGen);\n  let neighbors : PointNodeRef[] = []\n  for (let direction of enumKeys(Direction)) {\n    let it = neighborsMap[direction];\n    if (it) {\n      neighbors.push(it);\n    }\n  }\n  return neighbors;\n}\n\n// TODO(bowei): support vertical neighbors\nexport function getNeighborsMap(selfPointNodeRef: PointNodeRef, worldGen: WorldGenState): NeighborsMap {\n  let neighbors: NeighborsMap = {}\n\n  let zLevel = worldGen.zLevels[selfPointNodeRef.z]!\n  let myChunk = zLevel.chunks.get(selfPointNodeRef.chunkCoord)!;\n  // first, the right neighbor:\n  if (selfPointNodeRef.pointNodeCoord.x === ChunkGenConstants.CHUNK_HALF_DIM) {\n    let chunkCoord = selfPointNodeRef.chunkCoord.addX(1)\n    let chunk = zLevel.chunks.get(chunkCoord);\n    if (chunk) {\n      let pointNodeCoord = selfPointNodeRef.pointNodeCoord.withX(-ChunkGenConstants.CHUNK_HALF_DIM)\n      let nbor = chunk.pointNodes.get(pointNodeCoord);\n      if (nbor) {\n        neighbors.right = new PointNodeRef({\n          z: selfPointNodeRef.z,\n          chunkCoord,\n          pointNodeCoord,\n          pointNodeId: nbor.id\n        })\n      }\n    }\n  } else {\n    let pointNodeCoord = selfPointNodeRef.pointNodeCoord.addX(1);\n    let nbor = myChunk.pointNodes.get(pointNodeCoord);\n    if (nbor) {\n      neighbors.right = new PointNodeRef({\n        z: selfPointNodeRef.z,\n        chunkCoord: selfPointNodeRef.chunkCoord,\n        pointNodeCoord,\n        pointNodeId: nbor.id\n      })\n    }\n  }\n  // left neighbor\n  if (selfPointNodeRef.pointNodeCoord.x === -ChunkGenConstants.CHUNK_HALF_DIM) {\n    let chunkCoord = selfPointNodeRef.chunkCoord.addX(-1)\n    let chunk = zLevel.chunks.get(chunkCoord);\n    if (chunk) {\n      let pointNodeCoord = selfPointNodeRef.pointNodeCoord.withX(ChunkGenConstants.CHUNK_HALF_DIM)\n      let nbor = chunk.pointNodes.get(pointNodeCoord);\n      if (nbor) {\n        neighbors.left = new PointNodeRef({\n          z: selfPointNodeRef.z,\n          chunkCoord,\n          pointNodeCoord,\n          pointNodeId: nbor.id\n        })\n      }\n    }\n  } else {\n    let pointNodeCoord = selfPointNodeRef.pointNodeCoord.addX(-1);\n    let nbor = myChunk.pointNodes.get(pointNodeCoord);\n    if (nbor) {\n      neighbors.left = new PointNodeRef({\n        z: selfPointNodeRef.z,\n        chunkCoord: selfPointNodeRef.chunkCoord,\n        pointNodeCoord,\n        pointNodeId: nbor.id\n      })\n    }\n  }\n  // +y is down\n  if (selfPointNodeRef.pointNodeCoord.y === ChunkGenConstants.CHUNK_HALF_DIM) {\n    let chunkCoord = selfPointNodeRef.chunkCoord.addY(1)\n    let chunk = zLevel.chunks.get(chunkCoord);\n    if (chunk) {\n      let pointNodeCoord = selfPointNodeRef.pointNodeCoord.withY(-ChunkGenConstants.CHUNK_HALF_DIM)\n      let nbor = chunk.pointNodes.get(pointNodeCoord);\n      if (nbor) {\n        neighbors.down = new PointNodeRef({\n          z: selfPointNodeRef.z,\n          chunkCoord,\n          pointNodeCoord,\n          pointNodeId: nbor.id\n        })\n      }\n    }\n  } else {\n    let pointNodeCoord = selfPointNodeRef.pointNodeCoord.addY(1);\n    let nbor = myChunk.pointNodes.get(pointNodeCoord);\n    if (nbor) {\n      neighbors.down = new PointNodeRef({\n        z: selfPointNodeRef.z,\n        chunkCoord: selfPointNodeRef.chunkCoord,\n        pointNodeCoord,\n        pointNodeId: nbor.id\n      })\n    }\n  }\n  // -y is up\n  if (selfPointNodeRef.pointNodeCoord.y === -ChunkGenConstants.CHUNK_HALF_DIM) {\n    let chunkCoord = selfPointNodeRef.chunkCoord.addY(-1)\n    let chunk = zLevel.chunks.get(chunkCoord);\n    if (chunk) {\n      let pointNodeCoord = selfPointNodeRef.pointNodeCoord.withY(ChunkGenConstants.CHUNK_HALF_DIM)\n      let nbor = chunk.pointNodes.get(pointNodeCoord);\n      if (nbor) {\n        neighbors.up = new PointNodeRef({\n          z: selfPointNodeRef.z,\n          chunkCoord,\n          pointNodeCoord,\n          pointNodeId: nbor.id\n        })\n      }\n    }\n  } else {\n    let pointNodeCoord = selfPointNodeRef.pointNodeCoord.addY(-1);\n    let nbor = myChunk.pointNodes.get(pointNodeCoord);\n    if (nbor) {\n      neighbors.up = new PointNodeRef({\n        z: selfPointNodeRef.z,\n        chunkCoord: selfPointNodeRef.chunkCoord,\n        pointNodeCoord,\n        pointNodeId: nbor.id\n      })\n    }\n  }\n\n  return neighbors;\n}\n\nexport function canAllocate(\n  selfPointNodeRef: PointNodeRef,\n  worldGen: WorldGenState,\n  allocatedPointNodeSet: HashSet<PointNodeRef>,\n  availableSp: number\n): \"yes\" | \"already allocated\" | \"not enough sp\" | \"not connected\" {\n  if (allocatedPointNodeSet.contains(selfPointNodeRef)) {\n    return \"already allocated\";\n  }\n  if (availableSp < 1) {\n    return \"not enough sp\";\n  }\n  // check if any of our neighbors are allocated\n  const neighbors = getNeighbors(selfPointNodeRef, worldGen);\n  \n  for (let nbor of neighbors) {\n    if (allocatedPointNodeSet.contains(nbor)) {\n      return \"yes\";\n    }\n  }\n\n  return \"not connected\";\n}","import React from \"react\";\nimport { PointNodeRef, ResourceType, WorldGenState } from \"../data/GameState\";\nimport { HashSet } from \"../lib/util/data_structures/hash\";\nimport { canAllocate } from \"../game/Neighbors\";\n\ntype Props = {\n  selectedPointNode?: PointNodeRef\n  allocatedPointNodeSet: HashSet<PointNodeRef>,\n  worldGen: WorldGenState,\n  availableSp: number,\n}\n\nexport function NodeDetail({\n  selectedPointNode,\n  allocatedPointNodeSet,\n  worldGen,\n  availableSp,\n}: Props) {\n  if (!selectedPointNode) {\n    return (<>\n      <h1>Stats</h1>\n      <div>Select a node first!</div>\n    </>)\n  }\n  const pointNodeGen = worldGen.zLevels[selectedPointNode.z]!.chunks.get(selectedPointNode.chunkCoord)!.pointNodes.get(selectedPointNode.pointNodeCoord)!\n  const isAllocated = (allocatedPointNodeSet.contains(selectedPointNode));\n  const canBeAllocated: string = canAllocate(selectedPointNode, worldGen, allocatedPointNodeSet, availableSp);\n  let nodeDescription: string = \"Nothing (empty node)\";\n  if (pointNodeGen.resourceType !== ResourceType.Nothing) {\n    nodeDescription = `${pointNodeGen.resourceAmount} ${pointNodeGen.resourceModifier} ${pointNodeGen.resourceType}`\n  }\n  return (\n    <>\n      <h1>Stats</h1>\n      <div> {nodeDescription} </div>\n      <h3>Allocated?</h3>\n      {isAllocated ? \"yes\" : \"no\"}\n      <h3>Can be allocated?</h3>\n      {canBeAllocated}\n    </>\n  );\n}\n","import React from \"react\";\nimport { GameState } from \"./data/GameState\";\nimport { Const } from \"./lib/util/misc\";\nimport { UpdaterGeneratorType2 } from \"./lib/util/updaterGenerator\";\n\n// nullable, but should be OK, just remember to populate the context\n// export const GameContext = React.createContext<GameState>(null as any);\n// export const GameUpdatersContext = React.createContext<UpdaterGeneratorType<GameState>>(null as any);\nexport const UseGameStateContext = React.createContext<[Const<GameState>, UpdaterGeneratorType2<GameState>, () => void]>([] as any);","import React, { useContext, useEffect, useRef } from \"react\";\nimport { UseGameStateContext } from \"../contexts\";\nimport { PixiReactBridge } from \"../pixi/PixiReactBridge\";\nimport { WindowState } from \"../data/GameState\";\n\nexport function PixiWrapperComponent(props: {\n  application: PixiReactBridge,\n  windowState: WindowState,\n  fireBatchedSetWindowState: () => void,\n}) {\n  const { application, windowState } = props;\n  const container = useRef<HTMLDivElement>(null);\n  const [gameState, gameStateUpdaters, fireBatchedSetGameState]  = useContext(UseGameStateContext);\n  const fireBatch = () => {\n      fireBatchedSetGameState();\n      props.fireBatchedSetWindowState();\n    }\n\n  useEffect(() => {\n    // this block only triggers if a new application instance is created.\n    // first remove old application\n    // const oldLength = container.current!.childNodes.length;\n    for (let i = container.current!.childNodes.length - 1; i >= 0; i--) {\n      container.current!.removeChild(container.current!.childNodes[i]);\n    }\n    // if (oldLength != 0) {\n    //   return;\n    // }\n    // add the application\n    container.current!.appendChild(application.app.view);\n  }, [application]);\n\n  // const prevRef = useRef<Const<GameState>>();\n  // useEffect(() => {\n  //   prevRef.current = gameState;\n  // });\n  // const prevGameState = prevRef.current;\n\n  // Trigger component render on first load and also when game state is updated\n  application.rerender({\n    args: {\n      fireBatch, \n      isSecondConstructorCall: false,\n    },\n    updaters: gameStateUpdaters,\n    windowState,\n    gameState,\n  })\n\n  return (\n    <>\n      <div ref={container} />\n    </>\n  );\n}","export const EPSILON = 0.0000001;\n\nexport const epsEqual = (x: number, y: number) => {\n  return Math.abs(x - y) < EPSILON;\n}\n\nexport const epsGreaterThan = (x: number, y: number) => {\n  return (x + EPSILON - y) > 0;\n}\n\nexport const epsLessThan = (x: number, y: number) => {\n  return (x - EPSILON - y) < 0;\n}","import { EPSILON } from \"../epsilon_math\";\nimport { Util } from \"../misc\";\n\nexport interface IVector2 {\n  x: number;\n  y: number;\n}\n\nexport class Vector2 {\n  private _x: number;\n  private _y: number;\n\n  public get x(): number { return this._x; }\n  public get y(): number { return this._y; }\n\n  constructor();\n  constructor(x: number, y: number);\n  constructor(props: { x: number, y: number });\n  constructor(propsOrX: { x: number, y: number } | number = { x: 0, y: 0 }, y?: number) {\n    if (typeof propsOrX === \"number\") {\n      this._x = propsOrX;\n      this._y = y!;\n    } else {\n      this._x = propsOrX.x;\n      this._y = propsOrX.y;\n    }\n  }\n\n  public get half(): Vector2 {\n    return new Vector2({ x: this.x / 2, y: this.y / 2 });\n  }\n\n  public static Zero: Vector2 = new Vector2(0, 0);\n  public static One: Vector2 = new Vector2(1, 1);\n\n  static IsVector2(x: any): x is Vector2 {\n    return x instanceof Vector2;\n  }\n\n  static Random(highX: number, highY: number, lowX = 0, lowY = 0) {\n    return new Vector2({\n      x: Util.RandRange(lowX, highX),\n      y: Util.RandRange(lowY, highY),\n    });\n  }\n\n  hash(): string {\n    return this.toString();\n  }\n\n  toString(): string {\n    return `[${this.x}, ${this.y}]`;\n  }\n\n  invert(): Vector2 {\n    return new Vector2({\n      x: -this.x,\n      y: -this.y,\n    });\n  }\n\n  round(): Vector2 {\n    return new Vector2({\n      x: Math.round(this.x),\n      y: Math.round(this.y),\n    });\n  }\n\n  floor(): Vector2 {\n    return new Vector2({\n      x: Math.floor(this.x),\n      y: Math.floor(this.y),\n    });\n  }\n\n  taxicabDistance(p: Vector2): number {\n    return Math.abs(p.x - this.x) + Math.abs(p.y - this.y);\n  }\n\n  diagonalDistance(p: IVector2): number {\n    return Math.max(Math.abs(p.x - this.x), Math.abs(p.y - this.y));\n  }\n\n  distance(p: IVector2): number {\n    let dx = Math.abs(p.x - this.x);\n    let dy = Math.abs(p.y - this.y);\n\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  translate(p: { x: number, y: number }): Vector2 {\n    return new Vector2({\n      x: this.x + p.x,\n      y: this.y + p.y,\n    });\n  }\n\n  subtract(p: { x: number, y: number }): Vector2 {\n    return new Vector2({\n      x: this.x - p.x,\n      y: this.y - p.y,\n    });\n  }\n\n  add(p: { x: number, y: number }): Vector2 {\n    return new Vector2({\n      x: this.x + p.x,\n      y: this.y + p.y,\n    });\n  }\n\n  addX(x: number): Vector2 {\n    return new Vector2({\n      x: this.x + x,\n      y: this.y,\n    });\n  }\n\n  addY(y: number): Vector2 {\n    return new Vector2({\n      x: this.x,\n      y: this.y + y,\n    });\n  }\n\n  subtractX(x: number): Vector2 {\n    return new Vector2({\n      x: this.x - x,\n      y: this.y,\n    });\n  }\n\n  subtractY(y: number): Vector2 {\n    return new Vector2({\n      x: this.x,\n      y: this.y - y,\n    });\n  }\n\n  clampY(low: number, high: number): Vector2 {\n    let newY = this.y;\n\n    if (newY < low) { newY = low; }\n    if (newY > high) { newY = high; }\n\n    return new Vector2({\n      x: this.x,\n      y: newY,\n    });\n  }\n\n  scale(about: { x: number; y: number }, amount: { x: number; y: number }): Vector2 {\n    return new Vector2({\n      x: (this.x - about.x) * amount.x + about.x,\n      y: (this.y - about.y) * amount.y + about.y,\n    });\n  }\n\n  rotate(origin: Vector2, angle: number): Vector2 {\n    angle = angle / (180 / Math.PI);\n\n    return new Vector2({\n      x: Math.cos(angle) * (this.x - origin.x) - Math.sin(angle) * (this.y - origin.y) + origin.x,\n      y: Math.sin(angle) * (this.x - origin.x) + Math.cos(angle) * (this.y - origin.y) + origin.y,\n    });\n  }\n\n  equals(other: Vector2 | undefined): boolean {\n    if (other === undefined) {\n      return false;\n    }\n\n    return (\n      Math.abs(this.x - other.x) < EPSILON &&\n      Math.abs(this.y - other.y) < EPSILON\n    );\n  }\n\n  multiply(other: Vector2 | number): Vector2 {\n    if (typeof other === \"number\") {\n      return new Vector2({\n        x: this.x * other,\n        y: this.y * other,\n      });\n    } else {\n      return new Vector2({\n        x: this.x * other.x,\n        y: this.y * other.y,\n      });\n    }\n  }\n\n  divide(other: Vector2 | number): Vector2 {\n    if (typeof other === \"number\") {\n      return new Vector2({\n        x: this.x / other,\n        y: this.y / other,\n      });\n    } else {\n      return new Vector2({\n        x: this.x / other.x,\n        y: this.y / other.y,\n      });\n    }\n  }\n\n  toJSON(): any {\n    return {\n      __type: \"Vector2\",\n      x: this.x,\n      y: this.y,\n    }\n  }\n\n  transform(trans: Vector2, scale: number): Vector2 {\n    return new Vector2({\n      x: Math.floor((this.x - trans.x) * scale),\n      y: Math.floor((this.y - trans.y) * scale),\n    });\n  }\n\n  normalize(): Vector2 {\n    if (this.x === 0 && this.y === 0) {\n      return this;\n    }\n\n    const length = Math.sqrt(this.x * this.x + this.y * this.y);\n\n    return new Vector2({\n      x: this.x / length,\n      y: this.y / length\n    });\n  }\n\n  withX(newX: number): Vector2 {\n    return new Vector2({\n      x: newX,\n      y: this.y,\n    });\n  }\n\n  withY(newY: number): Vector2 {\n    return new Vector2({\n      x: this.x,\n      y: newY,\n    });\n  }\n\n  invertX(): Vector2 {\n    return new Vector2({\n      x: -this.x,\n      y: this.y,\n    });\n  }\n\n  lerp(other: Vector2, t: number): Vector2 {\n    if (t > 1 || t < 0) { console.error(\"Lerp t must be between 0 and 1.\"); }\n    if (t === 0) return this;\n    if (t === 1) return other;\n\n    return this.scale({ x: 0, y: 0 }, { x: 1 - t, y: 1 - t }).add(other.scale({ x: 0, y: 0 }, { x: t, y: t }))\n  }\n\n  lerp2D(other: Vector2, tx: number, ty: number): Vector2 {\n    if (tx > 1 || tx < 0 || ty > 1 || ty < 0) { console.error(\"Lerp t must be between 0 and 1.\"); }\n    return this.scale({ x: 0, y: 0 }, { x: 1 - tx, y: 1 - ty }).add(other.scale({ x: 0, y: 0 }, { x: tx, y: ty }))\n  }\n\n  coserp(other: Vector2, t: number): Vector2 {\n    t = 0.5 * (1 + Math.cos(2 * t * Math.PI));\n\n    return this.lerp(other, t);\n  }\n\n  static Deserialize(obj: any): Vector2 {\n    if (!obj.hasOwnProperty(\"x\") || !obj.hasOwnProperty(\"y\")) {\n      console.error(\"Failed deserializing point\");\n    }\n\n    return new Vector2({\n      x: obj.x,\n      y: obj.y,\n    });\n  }\n\n  static Serialize(obj: Vector2): string {\n    return JSON.stringify({ x: obj.x, y: obj.y });\n  }\n}","/**\n * Intended as a typescript-friendly replacement for {[k: string]: boolean} that allows us to specify what the key type should be (\n * rather than allowing any keyType.toString() to be a valid key, and without going through the trouble of declaring distinguishable\n * types for each key type we want to use). Also serves as a slightly different version of ES6 native Set(), which is hardcoded\n * to use === for object referential equality.\n * \n * NOTE: this assume hash() is a strong test for equality, i.e. 2 objects are considered equal if and only if their hashes are the same!!!\n * TODO: write StrictHashSet<K extends {hash(): string, equals(k: K): boolean}> to handle custom equality checks\n */\nexport class HashSet<K extends { hash(): string }> {\n  private _values: HashMap<K, K>;\n\n  constructor(initialValues: K[] = []) {\n    this._values = new HashMap<K, K>();\n\n    for (const value of initialValues) {\n      this.put(value);\n    }\n  }\n\n  remove(key: K): void {\n    this._values.remove(key);\n  }\n\n  put(key: K): void {\n    this._values.put(key, key);\n  }\n\n  get(key: K): boolean {\n    return this._values.get(key) !== undefined;\n  }\n\n  contains(key: K): boolean {\n    return this._values.contains(key);\n  }\n\n  values(): K[] {\n    return this._values.values();\n  }\n\n  // hash(): string {\n  //   return this._values.hashKeyset();\n  // }\n\n  clone(): HashSet<K> {\n    let n = new HashSet<K>();\n    n._values = this._values.clone()\n    return n;\n  }\n\n  size(): number {\n    return this._values.size();\n  }\n\n  // *[Symbol.iterator]() {\n  //   // construct a new iterator. note that as usual\n  //   for (let key of Object.keys(this._values)) {\n  //     yield key;\n  //   }\n  // }\n}\n\n/**\n * Intended as a typescript-friendly replacement for {[k: string]: V} that allows us to specify what the key type should be (\n * rather than allowing any keyType.toString() to be a valid key, and without going through the trouble of declaring distinguishable\n * types for each key type we want to use). Also serves as a slightly different version of ES6 native Map(), which is hardcoded\n * to use === for object referential equality.\n * \n * NOTE: this assume hash() is a strong test for equality, i.e. 2 objects are considered equal if and only if their hashes are the same!!!\n * TODO: write StrictHashMap<K extends {hash(): string, equals(K): boolean}> to handle custom equality checks\n */\nexport class HashMap<K extends { hash(): string }, V> {\n  protected _values: { [key: string]: V } = {};\n\n  put(key: K, value: V) {\n    this._values[key.hash()] = value;\n  }\n\n  remove(key: K): void {\n    delete this._values[key.hash()];\n  }\n\n  get(key: K): V | undefined {\n    return this._values[key.hash()];\n  }\n\n  contains(key: K): boolean {\n    // V may be an undefined type\n    return this.get(key) !== undefined && key.hash() in this._values;\n  }\n\n  values(): V[] {\n    return Object.values(this._values);\n    // return Object.keys(this._values).map(key => this._values[key]); // why grant???\n  }\n\n  // *[Symbol.iterator]() {\n  //   // construct a new iterator. note that as usual editing the object during iteration is not supported\n  //   for (let key of Object.keys(this._values)) {\n  //     yield key;\n  //   }\n  // }\n\n  // hashes only the keys - use HashableHashMap if you know that the value type here is also hashable\n  // hashKeyset(): string {\n  //   const hashes: number[] = Object.keys(this._values).map(s => hashCode(s));\n  //   let code: number = hashes.reduce((pv, cv) => pv + cv);\n  //   return code.toString();\n  // }\n\n  size(): number {\n    return Object.keys(this._values).length;\n  }\n\n  clone(): HashMap<K, V> {\n    let n = new HashMap<K, V>();\n    n._values = { ...this._values };\n    return n;\n  }\n}\n\nexport class HashableHashMap<K extends { hash(): string }, V extends { hash(): string }> extends HashMap<K, V> {\n  hash(): string {\n    const hashes: number[] = Object.entries(this._values).map(([s, v]) => hashCode(s) + hashCode(v.hash()));\n    let code: number = hashes.reduce((pv, cv) => pv + cv);\n    return code.toString();\n  }\n}\n\n/**\n * Same as HashMap, but actually stores the keys used to key the hashmap, instead of just their hashes.\n * Allows iteration over the full key-value pair set.\n */\nexport class KeyedHashMap<K extends { hash(): string }, V>{\n  private _kvalues: { [key: string]: [K, V] } = {};\n\n  put(key: K, value: V) {\n    this._kvalues[key.hash()] = [key, value];\n  }\n\n  remove(key: K): void {\n    delete this._kvalues[key.hash()];\n  }\n\n  get(key: K): V | undefined {\n    return this._kvalues[key.hash()]?.[1];\n  }\n\n  contains(key: K): boolean {\n    // V may be an undefined type\n    return this.get(key) !== undefined && key.hash() in this._kvalues;\n  }\n\n  keys(): K[] {\n    return Object.keys(this._kvalues).map(key => this._kvalues[key][0]);\n  }\n\n  entries(): ([K, V])[] {\n    return Object.keys(this._kvalues).map(key => this._kvalues[key]);\n  }\n\n  values(): V[] {\n    return Object.keys(this._kvalues).map(key => this._kvalues[key][1]);\n  }\n\n  hashKeyset(): string {\n    const hashes: number[] = Object.keys(this._kvalues).map(s => hashCode(s));\n    let code: number = hashes.reduce((pv, cv) => pv + cv);\n    return code.toString();\n  }\n\n  clone(): KeyedHashMap<K, V> {\n    let n = new KeyedHashMap<K, V>();\n    n._kvalues = { ...this._kvalues };\n    return n;\n  }\n\n}\n\nexport class DefaultHashMap<K extends { hash(): string }, V> {\n  private _values: { [key: string]: V } = {};\n  private _makeDefault: () => V;\n\n  constructor(makeDefaultValue: () => V) {\n    this._makeDefault = makeDefaultValue;\n  }\n\n  put(key: K, value: V) {\n    this._values[key.hash()] = value;\n  }\n\n  get(key: K): V {\n    if (this._values[key.hash()] === undefined) {\n      this._values[key.hash()] = this._makeDefault();\n    } \n\n    return this._values[key.hash()];\n  }\n}\n\n// Hash a string to a number. source: https://gist.github.com/hyamamoto/fd435505d29ebfa3d9716fd2be8d42f0\nexport function hashCode(s: string): number {\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = Math.imul(31, h) + s.charCodeAt(i) | 0;\n  }\n  return h;\n}\n\n// declare global {\n//   interface Array<T extends { hash(): string }> {\n//     hash(): string\n//   }\n// \n//   interface Number {\n//     hash(): string\n//   }\n// \n//   interface String {\n//     hash(): String\n//   }\n// }\n// \n// Array.prototype.hash = function () {\n//   return hashArray(this);\n// }\n// \n// Number.prototype.hash = function () {\n//   return this.toString();\n// }\n// \n// String.prototype.hash = function () {\n//   return this;\n// }\n// \n// function hashArray<T extends { hash(): string }>(arr: T[]): string {\n//   return arr.map(elt => hashCode(elt.hash())).reduce((pv, cv) => 31 * pv + cv).hash();\n// }\n// ","import * as Pixi from \"pixi.js\";\nimport { IVector2 } from \"../util/geometry/vector2\";\n\nexport function PixiPointFrom(p: IVector2): Pixi.Point {\n  return new Pixi.Point(p.x, p.y);\n}","import { GameState, PlayerSaveState, PointNodeRef } from \"../data/GameState\";\nimport { canAllocate } from \"./Neighbors\";\n\nexport function doTryAllocate(prev: PlayerSaveState, prevGameState: GameState, selfPointNodeRef: PointNodeRef): [PlayerSaveState, boolean] {\n  if (canAllocate(\n    selfPointNodeRef,\n    prevGameState.worldGen,\n    prevGameState.playerSave.allocatedPointNodeSet,\n    prevGameState.playerSave.availableSp\n  ) === 'yes') {\n    // do the change\n    const nextSet = prev.allocatedPointNodeSet.clone();\n    nextSet.put(selfPointNodeRef);\n    const nextHistory = [...prev.allocatedPointNodeHistory];\n    nextHistory.push(selfPointNodeRef);\n    let availableSp = prev.availableSp - 1;\n    return [{\n      ...prev,\n      allocatedPointNodeHistory: nextHistory,\n      allocatedPointNodeSet: nextSet,\n      availableSp\n    }, true];\n  } else {\n    return [prev, false];\n  }\n}\n\nexport function afterMaybeSpendingSp(prev: PlayerSaveState, prevGameState: GameState): PlayerSaveState {\n  if (prev.availableSp === 0 && prev.activeQuest) {\n    // TODO: need to find out if the quest is finished...\n    return {\n      ...prev,\n      availableSp: 5,\n      batchesSinceQuestStart: prev.batchesSinceQuestStart + 1\n    };\n  }\n  return prev;\n}","import { ComputedState, GameState, ResourceModifier, ResourceNontrivialType, ResourceType, ResourceTypeAndModifier } from \"../data/GameState\";\nimport { HashMap } from \"../lib/util/data_structures/hash\";\nimport { enumKeys } from \"../lib/util/misc\";\n\nexport function computePlayerResourceAmounts(gameState: GameState): ComputedState {\n  let amounts: { [k in ResourceType]?: number } = {};\n\n  let playerResourceNodesAggregated = new HashMap<ResourceTypeAndModifier, number>();\n\n  for (let pointNodeRef of gameState.playerSave.allocatedPointNodeHistory) {\n    let pointNodeGen = gameState.worldGen.zLevels[pointNodeRef.z]!.chunks.get(pointNodeRef.chunkCoord)!.pointNodes.get(pointNodeRef.pointNodeCoord)!\n    if (pointNodeGen.resourceType === \"Nothing\") {\n      continue;\n    }\n\n    let resourceTypeAndModifier = new ResourceTypeAndModifier({\n      type: pointNodeGen.resourceType, modifier: pointNodeGen.resourceModifier\n    });\n    \n    playerResourceNodesAggregated.put(resourceTypeAndModifier,\n      (playerResourceNodesAggregated.get(resourceTypeAndModifier) || 0) + pointNodeGen.resourceAmount);\n  }\n\n  // Do the +flat, %increased, etc. calculations here\n\n  for (let key of enumKeys(ResourceNontrivialType)) {\n    // iterate throu\n    let amount = playerResourceNodesAggregated.get(new ResourceTypeAndModifier({\n      type: key,\n      modifier: ResourceModifier.Flat\n    })) || 0;\n    amount *= (1 + .01 * (playerResourceNodesAggregated.get(new ResourceTypeAndModifier({\n      type: key,\n      modifier: ResourceModifier.Increased0,\n    })) || 0));\n    amount = Math.floor(amount);\n    amount += playerResourceNodesAggregated.get(new ResourceTypeAndModifier({\n      type: key,\n      modifier: ResourceModifier.AfterIncreased0\n    })) || 0;\n    amount *= (1 + .01 * (playerResourceNodesAggregated.get(new ResourceTypeAndModifier({\n      type: key,\n      modifier: ResourceModifier.Increased1,\n    })) || 0));\n    amount = Math.floor(amount);\n    amount += playerResourceNodesAggregated.get(new ResourceTypeAndModifier({\n      type: key,\n      modifier: ResourceModifier.AfterIncreased1\n    })) || 0;\n    amounts[key] = amount;\n  }\n\n  return {\n    playerResourceAmounts: amounts as { [k in ResourceType]: number },\n    playerResourceNodesAggregated\n  };\n}","import * as Pixi from \"pixi.js\";\nimport { RenderedChunkConstants } from \"./ChunkComponent\";\nimport { UpdaterGeneratorType2 } from \"../../lib/util/updaterGenerator\";\nimport { GameState, PointNodeGen, PointNodeRef, ResourceType } from \"../../data/GameState\";\nimport { Vector2 } from \"../../lib/util/geometry/vector2\";\nimport { PixiPointFrom } from \"../../lib/pixi/pixify\";\nimport { multiplyColor } from \"../../lib/util/misc\";\nimport { afterMaybeSpendingSp, doTryAllocate } from \"../../game/OnAllocation\";\nimport { computePlayerResourceAmounts } from \"../../game/ComputeState\";\n\ntype Props = {\n  delta: number,\n  args: {\n    pointNodeTexture: Pixi.Texture,\n    selfPointNodeRef: PointNodeRef,\n  },\n  updaters: UpdaterGeneratorType2<GameState>,\n  position: Vector2,\n  pointNodeGen: PointNodeGen,\n  isSelected: boolean,\n  isAllocated: boolean\n};\n\ntype State = {\n  justTriedToAllocate: boolean\n  justSpentSp: boolean\n  justFailedToAllocate: boolean\n  numClicks:number\n}\n\nexport class PointNodeComponent {\n  public container: Pixi.Container;\n  staleProps!: Props;\n  state!: State;\n  public sprite: Pixi.Sprite\n  public centerSprite: Pixi.Sprite;\n\n  constructor(props: Props) {\n    this.staleProps = props;\n    this.state = {\n      justTriedToAllocate: false,\n      justSpentSp: false,\n      justFailedToAllocate: false,\n      numClicks: 0\n    };\n    this.container = new Pixi.Container();\n    this.container.sortableChildren = true;\n    this.sprite = new Pixi.Sprite(props.args.pointNodeTexture);\n    this.sprite.anchor.x = 0.5;\n    this.sprite.anchor.y = 0.5;\n    this.sprite.zIndex = -1;\n    this.container.addChild(this.sprite);\n\n    this.centerSprite = new Pixi.Sprite(props.args.pointNodeTexture);\n    this.centerSprite.anchor.x = 0.5;\n    this.centerSprite.anchor.y = 0.5;\n    this.centerSprite.scale = PixiPointFrom(new Vector2(0.5, 0.5));\n    this.centerSprite.zIndex = 1;\n    this.container.addChild(this.centerSprite);\n\n    // this.container.mask\n\n    this.container.interactive = true;\n    this.container.buttonMode = true;\n    this.container.hitArea = new Pixi.Rectangle(\n      - RenderedChunkConstants.NODE_HITAREA_PX / 2,\n      - RenderedChunkConstants.NODE_HITAREA_PX / 2,\n      RenderedChunkConstants.NODE_HITAREA_PX,\n      RenderedChunkConstants.NODE_HITAREA_PX,\n    );\n    this.renderSelf(props);\n    this.didMount();\n  }\n\n  renderSelf(props: Props) {\n    this.container.position = PixiPointFrom(props.position);\n    let tint: number;\n    let centerTint: number;\n    if (props.isSelected) {\n      tint = 0xBBBBFF;\n      centerTint = 0xBBBBFF;\n    } else {\n      tint = 0xFFFFFF;\n      centerTint = 0xFFFFFF;\n    }\n    if (props.isAllocated) {\n      tint = 0x444444;\n    } else {\n    }\n    let baseColor: number = 0;\n    switch (props.pointNodeGen.resourceType) {\n      case ResourceType.Nothing:\n        baseColor = 0x99bbff; // blue that mixes in with bg\n        break;\n      case ResourceType.Mana0:\n        baseColor = 0xeeaaaa; // red\n        break;\n      case ResourceType.Mana1:\n        baseColor = 0xbb7733; // brown?\n        break;\n      case ResourceType.Mana2:\n        baseColor = 0x44aa44; // green\n        break;\n    }\n\n    this.sprite.tint = multiplyColor(baseColor, tint);\n    this.centerSprite.tint = multiplyColor(baseColor, centerTint);\n  }\n\n  updateSelf(props: Props) { }\n  shouldUpdate(prevProps: Props, props: Props): boolean {\n    for (let key of (Object.keys(prevProps) as (keyof Props)[])) {\n      if (key === 'delta' || key === 'args' || key === 'updaters') { continue; }\n      if (prevProps[key] !== props[key]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public update(props: Props) {\n    if (!this.shouldUpdate(this.staleProps, props)) { return; }\n    this.updateSelf(props);\n    this.renderSelf(props);\n    this.staleProps = props;\n  }\n\n  didMount() {\n    const { args, updaters } = this.staleProps; // we assume this will never change\n\n\n    this.container.addListener(\"pointerdown\", (event: Pixi.InteractionEvent) => {\n      this.state.numClicks++;\n      // event.stopPropagation();\n\n      // update selected to ourselves\n      updaters.playerUI.selectedPointNode.enqueueUpdate((prev, gameState) => {\n        if (prev?.pointNodeId === args.selfPointNodeRef.pointNodeId) {\n          this.state.justTriedToAllocate = true;\n        }\n        return args.selfPointNodeRef;\n      });\n\n      // if we tried to allocate ourselves, see if we can\n      updaters.playerSave.enqueueUpdate((prev, prevGameState) => {\n        if (this.state.justTriedToAllocate) {\n          this.state.justTriedToAllocate = false;\n          let [next, succeeded] = doTryAllocate(prev, prevGameState, args.selfPointNodeRef);\n          if (succeeded) {\n            this.state.justSpentSp = true;\n            return next;\n          } else {\n            this.state.justFailedToAllocate = true;\n            return prev;\n          }\n        }\n        return prev;\n      });\n\n      // TODO(bowei): if we spent sp, remember to update quest status!!\n      updaters.enqueueUpdate((prev, prevGameState) => {\n        if (this.state.justSpentSp) {\n          // this.state.justSpentSp = false;\n          return {\n            ...prev,\n            playerSave: afterMaybeSpendingSp(prev.playerSave, prevGameState),\n            computed: {\n              ...computePlayerResourceAmounts(prevGameState)\n            }\n          };\n        }\n        return prev;\n      })\n\n      // if we failed to allocate, shift the active tab so the player can see why\n      updaters.playerUI.activeTab.enqueueUpdate((prev, prevGameState) => {\n        if (this.state.justFailedToAllocate) {\n          this.state.justFailedToAllocate = false;\n          return 1;\n        }\n        return prev;\n      });\n    });\n  }\n}","import * as Pixi from \"pixi.js\";\nimport { HashSet, KeyedHashMap } from \"../../lib/util/data_structures/hash\";\nimport { ChunkGen, ChunkGenConstants, ChunkRef, GameState, PointNodeRef } from \"../../data/GameState\";\nimport { PointNodeComponent } from \"./PointNodeComponent\";\nimport { UpdaterGeneratorType2 } from \"../../lib/util/updaterGenerator\";\nimport { Vector2 } from \"../../lib/util/geometry/vector2\";\nimport { PixiPointFrom } from \"../../lib/pixi/pixify\";\n\nexport class RenderedChunkConstants {\n  public static SPACING_PX: number = 24;\n  public static CHUNK_SPACING_PX: number = (ChunkGenConstants.CHUNK_DIM + 0.5) * RenderedChunkConstants.SPACING_PX;\n  public static NODE_SIZE_PX: number = 14;\n  public static NODE_HITAREA_PX: number = 18;\n  public static NODE_ROUNDED_PX: number = 4;\n}\n\ntype Props = {\n  delta: number,\n  args: {\n    pointNodeTexture: Pixi.Texture,\n    selfChunkRef: ChunkRef,\n  },\n  updaters: UpdaterGeneratorType2<GameState>,\n  position: Vector2,\n  chunkGen: ChunkGen,\n  selectedPointNode: PointNodeRef | undefined,\n  allocatedPointNodeSubset: HashSet<PointNodeRef>,\n}\n\nexport class ChunkComponent {\n  public container: Pixi.Container;\n  staleProps!: Props;\n  state!: {};\n\n  public children: KeyedHashMap<PointNodeRef, PointNodeComponent>;\n\n  constructor(props: Props) {\n    this.staleProps = props;\n    this.state = {};\n    this.container = new Pixi.Container();\n    this.children = new KeyedHashMap();\n\n    for (let [pointNodeCoord, pointNodeGen] of props.chunkGen.pointNodes.entries()) {\n      const pointNodeRef = new PointNodeRef({\n        z: props.args.selfChunkRef.z,\n        chunkCoord: props.args.selfChunkRef.chunkCoord,\n        pointNodeCoord: pointNodeCoord,\n        pointNodeId: pointNodeGen.id\n      })\n      let childProps = {\n        delta: props.delta,\n        args: {\n          pointNodeTexture: props.args.pointNodeTexture,\n          selfPointNodeRef: pointNodeRef,\n        },\n        updaters: props.updaters,\n        pointNodeGen,\n        position: pointNodeRef.pointNodeCoord.multiply(RenderedChunkConstants.SPACING_PX),\n        isSelected: props.selectedPointNode?.pointNodeId === pointNodeRef.pointNodeId,\n        isAllocated: props.allocatedPointNodeSubset.contains(pointNodeRef),\n      };\n\n      let childComponent = new PointNodeComponent(childProps);\n      this.children.put(pointNodeRef, childComponent);\n      this.container.addChild(childComponent.container);\n    }\n\n    this.renderSelf(props);\n  }\n\n  renderSelf(props: Props) {\n    this.container.position = PixiPointFrom(props.position);\n  }\n\n  updateSelf(props: Props) { }\n  shouldUpdate(prevProps: Props, props: Props): boolean {\n    return true;\n    // for (let key of (Object.keys(prevProps) as (keyof Props)[])) {\n    //   if (key === 'delta' || key === 'args' || key === 'updaters') { continue; }\n    //   if (key === 'allocatedPointNodeSubset') {\n    //     // subsets could be different objects but have the same contents\n    //     if (prevProps[key].hash() !== props[key].hash()) {\n    //       return true;\n    //     } else {\n    //       continue;\n    //     }\n    //   }\n    //   if (prevProps[key] !== props[key]) {\n    //     return true;\n    //   }\n    // }\n    // return false;\n  }\n\n  public update(props: Props) {\n    if (!this.shouldUpdate(this.staleProps, props)) { return; }\n    this.updateSelf(props);\n    for (let [pointNodeCoord, pointNodeGen] of props.chunkGen.pointNodes.entries()) {\n      const pointNodeRef = new PointNodeRef({\n        z: props.args.selfChunkRef.z,\n        chunkCoord: props.args.selfChunkRef.chunkCoord,\n        pointNodeCoord: pointNodeCoord,\n        pointNodeId: pointNodeGen.id\n      })\n      let childProps = {\n        delta: props.delta,\n        args: {\n          pointNodeTexture: props.args.pointNodeTexture,\n          selfPointNodeRef: pointNodeRef,\n        },\n        updaters: props.updaters,\n        position: pointNodeRef.pointNodeCoord.multiply(RenderedChunkConstants.SPACING_PX),\n        pointNodeGen,\n        isSelected: props.selectedPointNode?.pointNodeId === pointNodeRef.pointNodeId,\n        isAllocated: props.allocatedPointNodeSubset.contains(pointNodeRef),\n      };\n\n      let childComponent = this.children.get(pointNodeRef);\n      if (childComponent) {\n        childComponent.update(childProps);\n      } else {\n        childComponent = new PointNodeComponent(childProps);\n        this.children.put(pointNodeRef, childComponent);\n        this.container.addChild(childComponent.container);\n      }\n    }\n    this.renderSelf(props);\n    this.staleProps = props;\n  }\n}\n","import { WorldGenState, ChunkGen, PointNodeGen, ChunkGenConstants, ZLevelGen, ResourceType, ResourceModifier } from \"../data/GameState\";\nimport { HashSet, KeyedHashMap } from \"../lib/util/data_structures/hash\";\nimport { Vector2 } from \"../lib/util/geometry/vector2\";\nimport { INTMAX32, squirrel3 } from \"../lib/util/random\";\n\nexport type WorldGenStateConfig = any;\n\nexport class WorldGenStateFactory {\n  public config: WorldGenStateConfig;\n\n  constructor(config: WorldGenStateConfig) {\n    this.config = config;\n  }\n\n  public create(): WorldGenState {\n    throw Error();\n  }\n}\n\nexport type ZLevelGenConfig = any;\n\nexport class ZLevelGenFactory {\n  public config: ZLevelGenConfig;\n  public chunkGenFactory: ChunkGenFactory;\n\n  constructor(config: ZLevelGenConfig) {\n    this.config = config;\n    this.chunkGenFactory = new ChunkGenFactory({});\n  }\n\n  public create(args: { seed: number, z: number, startingChunks?: number }): ZLevelGen {\n    const id = squirrel3(args.seed + args.z);\n    const chunks: KeyedHashMap<Vector2, ChunkGen> = new KeyedHashMap();\n\n    const max = args.startingChunks || 3;\n    // TODO(bowei): generate more chunks??\n    for (let i = -max; i <= max; i++) {\n      for (let j = -max; j <= max; j++){\n        let location = new Vector2(i, j);\n        chunks.put(location, this.chunkGenFactory.create({ seed: id, location, z: args.z }));\n      }\n    }\n\n    return { id, chunks };\n  }\n}\n\nexport type ChunkGenConfig = any;\n\nexport class ChunkGenFactory {\n  public config: ChunkGenConfig;\n  public pointNodeGenFactory: PointNodeGenFactory\n\n  constructor(config: ChunkGenConfig) {\n    this.config = config;\n    this.pointNodeGenFactory = new PointNodeGenFactory({});\n  }\n\n  public create(args: { seed: number, location: Vector2, z: number }): ChunkGen {\n    const id = squirrel3(args.seed + squirrel3(args.seed + args.location.x) + args.location.y);\n    const pointNodes: KeyedHashMap<Vector2, PointNodeGen> = new KeyedHashMap();\n\n    let droppedNodes: HashSet<Vector2> = new HashSet();\n    for (let i = -ChunkGenConstants.CHUNK_HALF_DIM; i <= ChunkGenConstants.CHUNK_HALF_DIM; i++) {\n      for (let j = -ChunkGenConstants.CHUNK_HALF_DIM; j <= ChunkGenConstants.CHUNK_HALF_DIM; j++) {\n        if (i === 0 && j === 0) {\n          continue;\n        }\n        // 4 way symmetry plz\n        if (squirrel3(id + i * ChunkGenConstants.CHUNK_DIM + j) / INTMAX32 < ChunkGenConstants.DROP_NODES_CHANCE / 4) {\n          droppedNodes.put(new Vector2(i, j));\n          droppedNodes.put(new Vector2(j, -i));\n          droppedNodes.put(new Vector2(-i, -j));\n          droppedNodes.put(new Vector2(-j, i));\n        }\n      }\n    }\n\n    for (let i = -ChunkGenConstants.CHUNK_HALF_DIM; i <= ChunkGenConstants.CHUNK_HALF_DIM; i++) {\n      for (let j = -ChunkGenConstants.CHUNK_HALF_DIM; j <= ChunkGenConstants.CHUNK_HALF_DIM; j++) {\n        let loc = new Vector2(i, j);\n        if (!droppedNodes.get(loc)) {\n          pointNodes.put(loc, this.pointNodeGenFactory.create({ seed: id, location: loc, chunk: args.location, z: args.z }));\n        }\n      }\n    }\n\n    return { id, pointNodes };\n  }\n}\n\ntype PointNodeGenConfig = {};\n\nexport class PointNodeGenFactory {\n  public config: PointNodeGenConfig;\n\n  constructor(config: PointNodeGenConfig) {\n    this.config = config;\n  }\n\n  public create(args: { seed: number, location: Vector2, chunk: Vector2, z: number }): PointNodeGen {\n    const id = squirrel3(args.seed + squirrel3(args.seed + args.location.x) + args.location.y);\n\n    let randomFloat = squirrel3(id + 1) / INTMAX32;\n    let resourceType: ResourceType;\n    if (randomFloat < 0.0) {\n      resourceType = \"Nothing\";\n    } else if (randomFloat < 0.20) {\n      resourceType = ResourceType.Mana0;\n    } else if (randomFloat < 0.35) {\n      resourceType = ResourceType.Mana1;\n    } else if (randomFloat < 0.60) {\n      resourceType = ResourceType.Mana2;\n    } else {\n      resourceType = \"Nothing\";\n    }\n    // override for root node\n    if (args.location.equals(Vector2.Zero) && args.chunk.equals(Vector2.Zero) && args.z === 0) {\n      resourceType = \"Nothing\";\n    }\n\n    randomFloat = squirrel3(id + 2) / INTMAX32;\n    let resourceModifier: ResourceModifier;\n    if (randomFloat < 0.70) {\n      resourceModifier = ResourceModifier.Flat;\n    } else if (randomFloat < 0.73) {\n      resourceModifier = ResourceModifier.AfterIncreased0;\n    } else if (randomFloat < 0.75) {\n      resourceModifier = ResourceModifier.AfterIncreased1;\n    } else if (randomFloat < 0.95) {\n      resourceModifier = ResourceModifier.Increased0;\n    } else {\n      resourceModifier = ResourceModifier.Increased1;\n    }\n\n    let resourceAmount = 0;\n    if (resourceModifier === ResourceModifier.Flat ||\n      resourceModifier === ResourceModifier.AfterIncreased0 ||\n      resourceModifier === ResourceModifier.AfterIncreased1) {\n      randomFloat = Math.floor(squirrel3(id + 3) / INTMAX32 * 4); // base is 20 ish?\n      randomFloat += Math.floor(squirrel3(id + 4) / INTMAX32 * 4); // base is 20 ish?\n      randomFloat += Math.floor(squirrel3(id + 5) / INTMAX32 * 4); // base is 20 ish?\n      resourceAmount = randomFloat * 20 + 60;\n    } else {\n      randomFloat = Math.floor(squirrel3(id + 3) / INTMAX32 * 2); // base is 20 ish?\n      randomFloat += Math.floor(squirrel3(id + 4) / INTMAX32 * 2); // base is 20 ish?\n      randomFloat += Math.floor(squirrel3(id + 5) / INTMAX32 * 2); // base is 20 ish?\n      randomFloat += Math.floor(squirrel3(id + 6) / INTMAX32 * 3); // base is 20 ish?\n      resourceAmount = randomFloat + 3;\n    }\n\n    return {\n      id,\n      resourceAmount,\n      resourceModifier,\n      resourceType\n    };\n  }\n}","\nconst logRowsToKeep: number = 60; // last 1 seconds, at 60 fps\n\n/**\n * See https://www.npmjs.com/package/pixi-fps https://github.com/jkanchelov/pixi-fps\n */\nexport class FpsTracker {\n  private frameTimestampsInTicks: any[] = [];\n  private frameTimestampsInTime: any[] = [];\n\n  constructor() {\n    this.frameTimestampsInTicks.push(0);\n    // this.frameTimestampsInTime.push((new Date()).getTime());\n  }\n\n  /**\n   * @param ticksSinceLastUpdate should be the delta in ticks since the last update - will probably be a decimal close to 1\n   */\n  public tick(ticksSinceLastUpdate: number) {\n    let lastFrameTime = this.frameTimestampsInTicks[this.frameTimestampsInTicks.length - 1];\n    this.frameTimestampsInTicks.push(lastFrameTime + ticksSinceLastUpdate);\n    \n    // rotate logs\n    if (this.frameTimestampsInTicks.length > logRowsToKeep + 60) {\n      this.frameTimestampsInTicks = this.frameTimestampsInTicks.slice(60);\n    }\n\n    // do the same but track real time\n    this.frameTimestampsInTime.push((new Date()).getTime());\n    if (this.frameTimestampsInTime.length > logRowsToKeep + 60) {\n      this.frameTimestampsInTime = this.frameTimestampsInTime.slice(60);\n    }\n  }\n\n  // [0, 3, 4] -> 30 fps\n  public getUps() : number {\n    let ticksDiff = this.frameTimestampsInTicks[this.frameTimestampsInTicks.length - 1] - this.frameTimestampsInTicks[0];\n    let framesDiff = this.frameTimestampsInTicks.length - 1;\n\n    let framesPerTick = framesDiff / ticksDiff;\n    if (!framesPerTick) {\n      return 60;\n    }\n\n    return framesPerTick * 60;\n  }\n\n  public getFps(): number {\n    let timeDiff = this.frameTimestampsInTime[this.frameTimestampsInTime.length - 1] - this.frameTimestampsInTime[0];\n    let framesDiff = this.frameTimestampsInTime.length - 1;\n\n    let framesPerMilli = framesDiff / timeDiff;\n    if (!framesPerMilli) {\n      return 60;\n    }\n\n    return framesPerMilli * 1000;\n  }\n\n  public getFpsString(): string {\n    let fpsNumber = this.getFps();\n\n    return fpsNumber.toFixed(1);\n  }\n\n  public getUpsString(): string {\n    let upsNumber = this.getUps();\n\n    return upsNumber.toFixed(1);\n  }\n}","import * as Pixi from \"pixi.js\";\nimport { FpsTracker } from \"../../lib/util/fpsTracker\";\nimport { Vector2 } from \"../../lib/util/geometry/vector2\";\nimport { PixiPointFrom } from \"../../lib/pixi/pixify\";\n\ntype FpsComponentProps = {\n  delta: number;\n  position: Vector2;\n  appSize: Vector2;\n}\n\nexport class FpsComponent {\n  public container: Pixi.Text;\n  staleProps: FpsComponentProps;\n  state: FpsTracker;\n\n  constructor(props: FpsComponentProps) {\n    this.container = new Pixi.Text('', {\n      fontFamily: 'PixelMix',\n      fontSize: 12,\n      // align: 'right'\n    });\n    this.state = new FpsTracker();\n    this.staleProps = props;\n\n    this.renderSelf(props)\n  }\n\n  public update(props: FpsComponentProps) {\n    this.updateSelf(props);\n    this.renderSelf(props);\n  }\n\n  updateSelf(props: FpsComponentProps) {\n    this.state.tick(props.delta);\n  }\n  renderSelf(props: FpsComponentProps) {\n    this.container.text = this.state.getFpsString() + \" FPS\\n\" + this.state.getUpsString() + \" UPS\\n\" +\n      props.appSize.x + \"x\" + props.appSize.y;\n    this.container.position = PixiPointFrom(props.position);\n  }\n}","\ntype UpdaterFnParam2<T, W> = ((prev: T, prevWhole: W) => T) | (T extends Function ? never : T) // (T | ((prev: T, prevWhole: W) => T));\ntype UpdaterFn2<T, W> = (arg: UpdaterFnParam2<T, W>) => void;\nexport type UpdaterGeneratorType2<T, W = T> = {\n  [k in keyof T]: ((T[k] extends { [kkt: string]: any } ? UpdaterGeneratorType2<T[k], W> : {}) & {\n    getUpdater: () => UpdaterFn2<T[k], W>,\n    enqueueUpdate: UpdaterFn2<T[k], W>,\n    update: UpdaterFn2<T[k], W>,\n  })\n} & {\n  getUpdater: () => UpdaterFn2<T, W>,\n  enqueueUpdate: UpdaterFn2<T, W>,\n  update: UpdaterFn2<T, W>,\n}\n\n// helper method for the recursion\nfunction updaterGenerator2Helper<T, W>(dataObject: T, dataUpdater: UpdaterFn2<T, W>): UpdaterGeneratorType2<T, W> {\n  const updaters: UpdaterGeneratorType2<T, W> = {} as any;\n  updaters.getUpdater = () => dataUpdater;\n  updaters.enqueueUpdate = dataUpdater;\n  updaters.update = dataUpdater;\n  if (typeof dataObject !== \"object\") return updaters;\n  else {\n    const keys: (keyof T)[] = Object.keys(dataObject) as any;\n    keys.forEach((key: (keyof T)) => {\n      if (key === \"enqueueUpdate\" || key === \"getUpdater\" || key === \"update\") {\n        throw Error(`Invalid key in updaterGenerator: ${key} conflicts with reserved keywords enqueueUpdate, update, getUpdater.`);\n      }\n      function keyUpdater(newValueOrCallback: UpdaterFnParam2<T[typeof key], W>) {\n        if (typeof newValueOrCallback === \"function\") {\n          dataUpdater((oldData: T, wholeData: W) => {\n            const newData = {\n              ...oldData,\n              [key]: (newValueOrCallback as ((prev: T[typeof key], whole: W) => T[typeof key]))(oldData[key], wholeData),\n            };\n            // console.log({ newData });\n            return newData;\n          });\n        } else {\n          dataUpdater((oldData, wholeData) => ({ ...oldData, [key]: newValueOrCallback }));\n        }\n      }\n      updaters[key] = (updaterGenerator2Helper<T[typeof key], W>(dataObject[key], keyUpdater) as unknown as (typeof updaters)[typeof key]);\n    });\n    return updaters;\n  }\n}\n\n/**\n * Convenience method for generating setState<FancyObject.sub.component>() from setState<FancyObject> callbacks.\n * If used in react, recommended that this be memoized.\n * \n * @generic T should be a data-only object - nested objects are allowed but arrays, sets not supported\n * @param dataObject ANY instance of T, used only for its keys. MUST have all keys present\n * @param setState an updater function, which can be called as: dataUpdater(newT) or\n *   dataUpdater((oldT) => { return newTFromOldT(oldT) }) ; e.g. react setState() function.\n * @return a deep object that has the same keys as T, except each key also has a getUpdater()/set/update member;\n *   the getUpdater() on a subobject of T acts similarly to the [setState] param but to the subobject rather than the whole object;\n *   the whole object is also available as the second argument of the callback\n * e.g. :\n *   let gameStateUpdater = updaterGenerator(skeletonObject, setGameState);\n *   let setName = gameStateUpdater.player.name.getUpdater();\n *   gameStateUpdater.player.name.set(newName);\n *   gameStateUpdater.player.name.update((oldName, wholeObject) => oldName + \" \");\n * \n */\nexport function updaterGenerator2<T>(dataObject: T, setState: UpdaterFn<T>): UpdaterGeneratorType2<T> {\n  const dataUpdater2 = (stateCallbackFunction: UpdaterFnParam2<T, T>) => {\n    if (typeof stateCallbackFunction === 'function') {\n      setState((prev: T) => {\n        // if T is a function type already, typescript correctly notifies us that this will fail\n        const next = (stateCallbackFunction as ((prev: T, prevWhole: T) => T))(prev, prev);\n        // console.log(\" in updater generator 2\", { next });\n        return next;\n      })\n    } else {\n      setState(stateCallbackFunction);\n    }\n  };\n  return updaterGenerator2Helper<T, T>(dataObject, dataUpdater2);\n}\n\nexport type UpdaterFnParam<T> = (T extends Function ? never  : T) | ((prev: T) => T);\nexport type UpdaterFn<T> = (arg: UpdaterFnParam<T>) => void;","import * as Pixi from \"pixi.js\";\nimport { ChunkRef, GameState, PointNodeRef, ZLevelGen } from \"../../data/GameState\";\nimport { ZLevelGenFactory } from \"../../game/WorldGenStateFactory\";\nimport { PixiPointFrom } from \"../../lib/pixi/pixify\";\nimport { HashSet, KeyedHashMap } from \"../../lib/util/data_structures/hash\";\nimport { Vector2 } from \"../../lib/util/geometry/vector2\";\nimport { Const } from \"../../lib/util/misc\";\nimport { UpdaterGeneratorType2 } from \"../../lib/util/updaterGenerator\";\nimport { RenderedChunkConstants, ChunkComponent } from \"./ChunkComponent\";\n\ntype Props = {\n  delta: number,\n  args: {\n    pointNodeTexture: Pixi.Texture,\n    z: number,\n  },\n  updaters: UpdaterGeneratorType2<GameState>,\n  position: Vector2,\n  zLevelGen: Const<ZLevelGen> | undefined,\n  selectedPointNode: PointNodeRef | undefined,\n  allocatedPointNodeSubset: Const<HashSet<PointNodeRef>>,\n}\n\nexport class ZLevelComponent {\n  public container: Pixi.Container;\n  staleProps!: Props;\n  state!: {};\n\n  public children: KeyedHashMap<ChunkRef, ChunkComponent> = new KeyedHashMap();\n\n  constructor(props: Props) {\n    this.staleProps = props;\n    this.state = {};\n    this.container = new Pixi.Container();\n\n    for (let [chunkCoord, chunkGen] of props.zLevelGen?.chunks?.entries() || []) {\n      const chunkRef = new ChunkRef({\n        z: props.args.z,\n        chunkCoord,\n        chunkId: chunkGen.id,\n      });\n\n      let allocatedPointNodeSubset = new HashSet(\n        props.allocatedPointNodeSubset.values()\n          .filter((pointNodeRef) => {\n            return pointNodeRef.chunkCoord.x === chunkRef.chunkCoord.x &&\n              pointNodeRef.chunkCoord.y === chunkRef.chunkCoord.y;\n          })\n      );\n      let childProps = {\n        delta: props.delta,\n        args: {\n          pointNodeTexture: props.args.pointNodeTexture,\n          selfChunkRef: chunkRef,\n        },\n        updaters: props.updaters,\n        position: chunkRef.chunkCoord.multiply(RenderedChunkConstants.CHUNK_SPACING_PX),\n        chunkGen: chunkGen,\n        selectedPointNode: props.selectedPointNode,\n        allocatedPointNodeSubset,\n      }\n      const childComponent = new ChunkComponent(childProps);\n      this.children.put(chunkRef, childComponent);\n      this.container.addChild(childComponent.container);\n\n    }\n\n    this.renderSelf(props);\n    this.didMount();\n  }\n\n  renderSelf(props: Props) {\n    this.container.position = PixiPointFrom(props.position);\n  }\n\n  updateSelf(props: Props) { }\n  shouldUpdate(prevProps: Props, props: Props): boolean {\n    for (let key of (Object.keys(prevProps) as (keyof Props)[])) {\n      if (key === 'delta' || key === 'args' || key === 'updaters') { continue; }\n      if (key === 'position') {\n        if (!prevProps[key].equals(props[key])) {\n          return true;\n        } else {\n          continue;\n        }\n      }\n      // if (key === 'allocatedPointNodeSubset') {\n      //   if (prevProps[key].hash() !== props[key].hash()) {\n      //     return true;\n      //   } else {\n      //     continue;\n      //   }\n      // }\n      if (prevProps[key] !== props[key]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public update(props: Props) {\n    if (!this.shouldUpdate(this.staleProps, props)) { return; }\n    this.updateSelf(props);\n    for (let [chunkCoord, chunkGen] of props.zLevelGen?.chunks?.entries() || []) {\n      const chunkRef = new ChunkRef({\n        z: props.args.z,\n        chunkCoord,\n        chunkId: chunkGen.id,\n      });\n\n      let allocatedPointNodeSubset = new HashSet(\n        props.allocatedPointNodeSubset.values()\n          .filter((pointNodeRef) => {\n            return pointNodeRef.chunkCoord.x === chunkRef.chunkCoord.x &&\n              pointNodeRef.chunkCoord.y === chunkRef.chunkCoord.y;\n          })\n      );\n      let childProps = {\n        delta: props.delta,\n        args: {\n          pointNodeTexture: props.args.pointNodeTexture,\n          selfChunkRef: chunkRef,\n        },\n        updaters: props.updaters,\n        position: chunkRef.chunkCoord.multiply(RenderedChunkConstants.CHUNK_SPACING_PX),\n        chunkGen: chunkGen,\n        selectedPointNode: props.selectedPointNode,\n        allocatedPointNodeSubset,\n      }\n      let childComponent = this.children.get(chunkRef);\n      if (childComponent) {\n        childComponent.update(childProps);\n      } else {\n        childComponent = new ChunkComponent(childProps);\n        this.children.put(chunkRef, childComponent);\n        this.container.addChild(childComponent.container);\n      }\n    }\n    this.renderSelf(props);\n    this.didUpdate(this.staleProps, props);\n    this.staleProps = props;\n    // this.staleProps.allocatedPointNodeSubset = this.staleProps.allocatedPointNodeSubset.clone();\n  }\n\n  didUpdate(prevProps: Props, props: Props) {\n\n  }\n\n  didMount() {\n    const { args, updaters } = this.staleProps;\n    // if we mounted but our data is not generated, please generate ourselves\n    updaters.worldGen.zLevels.update((prev, prevGameState) => {\n      if (!prev[args.z]) {\n        return { [args.z]: new ZLevelGenFactory({}).create({ seed: prevGameState.worldGen.seed, z: args.z }) };\n      }\n      return prev;\n    })\n    // updaters.playerSave.allocatedPointNodeSet.update((prev, prevGameState) => {\n    //   if (prev.size() === 0) {\n    //     let startNode = prevGameState.worldGen.zLevels[0].chunks.get(new Vector2(0, 0))?.pointNodes.get(new Vector2(0, 0));\n    //     if (startNode) {\n    //       prev.put(new PointNodeRef({\n    //         z: 0,\n    //         chunkCoord: new Vector2(0, 0),\n    //         pointNodeCoord: new Vector2(0, 0),\n    //         pointNodeId: startNode?.id\n    //       }))\n    //       return prev.clone();\n    //     }\n    //   }\n    //   return prev;\n    // })\n  }\n}\n","import * as Pixi from \"pixi.js\";\nimport { PixiPointFrom } from \"../../lib/pixi/pixify\";\nimport { Vector2 } from \"../../lib/util/geometry/vector2\";\n\ntype Props = {\n  appSize: Vector2\n}\n\ntype State = {\n  position: Vector2;\n}\n\nexport class ReticleComponent{\n  public container: Pixi.Graphics;\n  staleProps: Props\n  state: State;\n\n  constructor(props: Props) {\n    this.container = new Pixi.Graphics();\n    this.staleProps = props;\n    this.state = {\n      position: props.appSize.multiply(0.5)\n    };\n\n    this.container.lineStyle(2, 0x999999);\n    this.container.drawCircle(0, 0, 10);\n    this.container.interactive = true;\n    this.container.buttonMode = true;\n\n    this.renderSelf(props);\n  }\n\n  public update(props: Props) {\n    this.updateSelf(props);\n    this.renderSelf(props);\n    this.staleProps = props;\n  }\n\n  updateSelf(props: Props) {\n    this.state.position = props.appSize.multiply(0.5);\n  }\n  renderSelf(props: Props) {\n    this.container.position = PixiPointFrom(this.state.position);\n  }\n\n\n}","/**\n * \n * @param fn an arbitrary callback which performs some operation with side effects.\n * @returns a tuple: [batchedFn, fireBatch]. \n * batchedFn takes the same arguments as fn, but the side effects are delayed until fireBatch is called.\n * if batchedFn is called multiple times, those invocations are stored in order, and then popped off in order when fireBatch is called.\n */\nexport function batchify<A extends any[]>(fn: (...args: A)=> void): [((...args: A) => void), () => void] {\n  let batch: A[] = [];\n\n  return [(...args: A) => {\n    batch.push(args);\n    // console.log({ stack: new Error().stack, batchSize: batch.length });\n    console.log({ batchSize: batch.length });\n  }, (() => {\n      if (batch.length !== 0) { console.log({ fired: batch.length }); }\n      for (let a of batch) {\n        fn(...a);\n      }\n      batch = [];\n    })\n  ];\n}\n\n/**\n * Same use case and types as [batchify], however, specifically we expect [fn] to be a setState function which takes value-or-callback\n * as its single argument, and instead of calling [fn] repeatedly for each callback in the batch, we apply the callbacks in the batch\n * sequentially to get a single state update which we then provide to [fn].\n */\nexport function batchifySetState<T>(\n  fn: (arg: T) => void\n): [((arg: T) => void), () => void] {\n  let batch: T[] = [];\n\n  return [(arg: T) => {\n    batch.push(arg);\n    console.log({ batchSize: batch.length });\n  }, (() => {\n      if (batch.length === 0) {\n        return;\n      }\n      console.log({ fired: batch.length });\n      let thisBatch = [...batch];\n      batch = [];\n      (fn as any)((prev: any) => {\n        let next = prev;\n        for (let valueOrCallback of thisBatch) {\n          if (typeof valueOrCallback === 'function') {\n            next = valueOrCallback(next);\n          } else {\n            next = valueOrCallback;\n          }\n        }\n        return next;\n      });\n  })]\n}\n\n","import * as Pixi from \"pixi.js\";\nimport { KeyboardState } from \"../../lib/pixi/keyboard\";\nimport { Vector2 } from \"../../lib/util/geometry/vector2\";\nimport { GameState} from \"../../data/GameState\";\nimport { generatePointNodeTexture } from \"../textures/PointNodeTexture\";\nimport { ZLevelGenFactory } from \"../../game/WorldGenStateFactory\";\nimport { Const, Lazy } from \"../../lib/util/misc\";\nimport { FpsComponent } from \"./FpsComponent\";\nimport { updaterGenerator2, UpdaterGeneratorType2, UpdaterFn } from \"../../lib/util/updaterGenerator\";\nimport { ZLevelComponent } from \"./ZLevelComponent\";\nimport { ReticleComponent } from \"./ReticleComponent\";\nimport { batchifySetState } from \"../../lib/util/batchify\";\n\nexport type PlayerIntentState = {\n  justDown: boolean;\n  justUp: boolean;\n  down: boolean;\n}\n\nexport function createPlayerIntentState() : PlayerIntentState {\n  return {\n    justDown: false,\n    justUp: false,\n    down: false\n  }\n}\n\ntype State = {\n  pointNodeTexture: Lazy<Pixi.Texture>;\n  tick: number;\n  playerIntents: {\n    decreaseZLevel: PlayerIntentState\n    increaseZLevel: PlayerIntentState\n    panLeft: PlayerIntentState\n    panRight: PlayerIntentState\n    panUp: PlayerIntentState\n    panDown: PlayerIntentState\n  }\n}\n\ntype Props = {\n  args: {\n    renderer: Pixi.Renderer,\n  },\n  updaters: UpdaterGeneratorType2<GameState>,\n  delta: number,\n  gameState: Const<GameState>,\n  appSize: Vector2\n}\n\nexport class RootComponent {\n  public container: Pixi.Container;\n  staleProps: Props;\n  state: State;\n  stateUpdaters: UpdaterGeneratorType2<State>;\n  fireStateUpdaters: () => void;\n\n  /* children */\n  // Contains HUD, and other entities that don't move when game camera moves\n  public fixedCameraStage: Pixi.Container;\n  // Contains game entities that move when game camera pans/zooms. Highly encouraged to have further subdivions.\n  public actionStage: Pixi.Container;\n  // Contains a few entities that doesn't move when game camera moves, but located behind action stage entities, e.g. static backgrounds\n  public backdropStage: Pixi.Container;\n  public keyboard!: KeyboardState;\n  public fpsTracker: FpsComponent;\n  public zLevel: ZLevelComponent | undefined;\n  public reticle: ReticleComponent;\n  public backdrop: Pixi.Graphics;\n\n  /**\n   * Need to provide config to set up the pixi canvas\n   */\n  constructor(props: Props) {\n    this.container = new Pixi.Container();\n    this.container.sortableChildren = true;\n    this.staleProps = props;\n    this.state = {\n      pointNodeTexture: new Lazy(() => generatePointNodeTexture(props.args.renderer)),\n      tick: 0,\n      playerIntents: {\n        decreaseZLevel: createPlayerIntentState(),\n        increaseZLevel: createPlayerIntentState(),\n        panLeft: createPlayerIntentState(),\n        panRight: createPlayerIntentState(),\n        panUp: createPlayerIntentState(),\n        panDown: createPlayerIntentState(),\n      }\n    };\n    const setState: UpdaterFn<State> = ((valueOrCallback) => {\n      if (typeof valueOrCallback === \"function\") {\n        this.state = valueOrCallback(this.state);\n      } else {\n        this.state = valueOrCallback;\n      }\n    })\n    let [batchedSetState, fireBatch] = batchifySetState(setState);\n    this.stateUpdaters = updaterGenerator2<State>(this.state, batchedSetState);\n    this.fireStateUpdaters = fireBatch;\n\n    this.fixedCameraStage = new Pixi.Sprite();\n    this.fixedCameraStage.zIndex = 1;\n    this.fixedCameraStage.sortableChildren = true;\n    this.container.addChild(this.fixedCameraStage);\n\n    this.actionStage = new Pixi.Sprite();\n    this.actionStage.zIndex = 0;\n    this.actionStage.sortableChildren = true;\n    this.container.addChild(this.actionStage);\n\n    this.backdropStage = new Pixi.Sprite();\n    this.backdropStage.zIndex = -1;\n    this.backdropStage.sortableChildren = true;\n    this.container.addChild(this.backdropStage);\n\n    // // this.keyboard = new KeyboardState();\n    // // this.app.ticker.add(() => {\n    // //   this.keyboard.update();\n    // // })\n\n    this.fpsTracker = new FpsComponent({\n      delta: props.delta,\n      position: new Vector2(0, 0),\n      appSize: props.appSize,\n    })\n    this.fixedCameraStage.addChild(this.fpsTracker.container);\n\n    this.backdrop = new Pixi.Graphics();\n    this.backdropStage.addChild(this.backdrop);\n    this.backdrop.beginFill(0xabcdef, 1);\n    // backdrop.alpha = 0.5; // if alpha == 0, Pixi does not register this as a hittable area\n    this.backdrop.interactive = true;\n    // backdrop.interactiveChildren = true; // not sure what this does\n    // backdrop.buttonMode = true; // changes the mouse cursor on hover to pointer; not desirable for the entire backdrop\n    this.backdrop.drawRect(0, 0, props.appSize.x, props.appSize.y);\n\n\n    this.reticle = new ReticleComponent({\n      appSize: props.appSize\n    });\n    this.fixedCameraStage.addChild(this.reticle.container);\n\n    const childProps = {\n      delta: 0,\n      args: {\n        pointNodeTexture: this.state.pointNodeTexture.get(),\n        z: 0,\n      },\n      updaters: props.updaters,\n      position: props.appSize.multiply(0.5),\n      zLevelGen: props.gameState.worldGen.zLevels[0],\n      selectedPointNode: props.gameState.playerUI.selectedPointNode,\n      allocatedPointNodeSubset: props.gameState.playerSave.allocatedPointNodeSet,\n    };\n    if (!this.zLevel) {\n      this.zLevel = new ZLevelComponent(childProps);\n      this.actionStage.addChild(this.zLevel.container);\n    } else {\n      this.zLevel.update(childProps);\n    }\n\n    this.renderSelf(props);\n    this.didMount();\n  }\n\n  shouldUpdate(prevProps: Props, props: Props): boolean {\n\n    let prevSize = prevProps.gameState.playerSave.allocatedPointNodeSet.size()\n    let nextSize = props.gameState.playerSave.allocatedPointNodeSet.size()\n    if (prevSize !== nextSize) { console.log('rootapp shouldUpdate', { prevSize, nextSize }); }\n    return true;\n  }\n\n  public update(props: Props) {\n    if (!this.shouldUpdate(this.staleProps, props)) { return; }\n    this.updateSelf(props)\n    // this.keyboard.update(props);\n    this.fpsTracker.update({\n      delta: props.delta,\n      position: new Vector2(0, 0),\n      appSize: props.appSize,\n    })\n\n    const childProps = {\n      delta: 0,\n      args: {\n        pointNodeTexture: this.state.pointNodeTexture.get(),\n        z: 0,\n      },\n      updaters: props.updaters,\n      position: props.appSize.multiply(0.5),\n      zLevelGen: props.gameState.worldGen.zLevels[0],\n      selectedPointNode: props.gameState.playerUI.selectedPointNode,\n      allocatedPointNodeSubset: props.gameState.playerSave.allocatedPointNodeSet,\n    };\n    if (!this.zLevel) {\n      this.zLevel = new ZLevelComponent(childProps);\n      this.actionStage.addChild(this.zLevel.container);\n    } else {\n      this.zLevel.update(childProps);\n    }\n\n    this.reticle.update({\n      appSize: props.appSize\n    })\n    this.renderSelf(props);\n    this.didUpdate(this.staleProps, props);\n    this.staleProps = props;\n    this.fireStateUpdaters();\n  }\n\n  updateSelf(props: Props) {\n    this.state.tick++;\n  }\n\n  renderSelf(props: Props) {\n    this.backdrop.width = props.appSize.x;\n    this.backdrop.height = props.appSize.y;\n  }\n\n  didMount() {\n    const { updaters } = this.staleProps;\n    this.backdrop.addListener('pointerdown', (event) => {\n      updaters.playerUI.selectedPointNode.enqueueUpdate((prev, whole) => {\n        return undefined;\n      })\n    });\n  }\n\n  willUnmount(props: Props) {\n  }\n\n  didUpdate(prevProps: Props, props: Props) {\n    const { updaters } = this.staleProps;\n    // if we find ourselves a little idle, start pregenerating other layers\n    if (this.state.tick > 60 && !props.gameState.worldGen.zLevels[-1]) {\n      updaters.worldGen.zLevels.update((prev, prevGameState) => {\n        if (!prev[-1]) {\n          prev[-1] = new ZLevelGenFactory({}).create({ seed: prevGameState.worldGen.seed, z: 0 });\n          return {...prev};\n        } else {\n          return prev;\n        }\n      })\n    }\n    if (this.state.tick > 120 && !props.gameState.worldGen.zLevels[1]) {\n      updaters.worldGen.zLevels.update((prev, prevGameState) => {\n        if (!prev[1]) {\n          prev[1] = new ZLevelGenFactory({}).create({ seed: prevGameState.worldGen.seed, z: 1 });\n          return {...prev};\n        } else {\n          return prev;\n        }\n      })\n    }\n  }\n}\n\n","import * as Pixi from \"pixi.js\";\nimport { RenderedChunkConstants } from \"../components/ChunkComponent\";\n\nexport function generatePointNodeTexture(renderer: Pixi.Renderer) {\n    let g = new Pixi.Graphics();\n    g.beginFill(0xffffff);\n    g.drawRoundedRect(\n      - RenderedChunkConstants.NODE_SIZE_PX / 2,\n      - RenderedChunkConstants.NODE_SIZE_PX / 2,\n      RenderedChunkConstants.NODE_SIZE_PX,\n      RenderedChunkConstants.NODE_SIZE_PX,\n      RenderedChunkConstants.NODE_ROUNDED_PX\n    );\n    // g.x = 200;\n    // g.y = 200;\n    // this.app.stage.addChild(g);\n    let texture = renderer.generateTexture(g, Pixi.SCALE_MODES.NEAREST, 1);\n    // const sprite = new Pixi.Sprite(texture);\n    // sprite.x = 300;\n    // sprite.y = 300;\n    // this.app.stage.addChild(sprite);\n  return texture;\n}","import * as Pixi from \"pixi.js\";\nimport { Vector2 } from \"../lib/util/geometry/vector2\";\nimport { GameState, WindowState } from \"../data/GameState\";\nimport { assertOnlyCalledOnce, Const } from \"../lib/util/misc\";\nimport { RootComponent } from \"./components/RootComponent\";\nimport { UpdaterGeneratorType2 } from \"../lib/util/updaterGenerator\";\n\ntype Props = {\n  args: {\n    fireBatch: () => void,\n    isSecondConstructorCall: boolean\n  },\n  updaters: UpdaterGeneratorType2<GameState>, // aka updaters\n  windowState: Const<WindowState>,\n  gameState: Const<GameState>,\n}\n\ntype State = {\n  appSize: Vector2,\n  originalAppSize: Vector2,\n}\n\nfunction appSizeFromWindowSize(window?: Const<Vector2>): Vector2 {\n  return new Vector2({\n    x: Math.min(1920, (window?.x || Infinity) - 24),\n    y: Math.min(1080, (window?.y || Infinity) - 24),\n  });\n}\n\nexport class PixiReactBridge {\n  public app!: Pixi.Application;\n\n  state!: State;\n  props!: Props;\n\n  RootComponent: RootComponent | undefined;\n  onTick!: (d: number) => void;\n\n  /**\n   * NOTE: for lifecycle convenience, we allow initializing with essentially empty props, and to finish the initialization\n   * lazily at the first rerender() call\n   */\n  constructor(props?: Props, isSecondConstructorCall: boolean = false) {\n    // verify that we are not loading this twice when we expect to load it only once -- bad for performance!!\n    if (!(props?.args?.isSecondConstructorCall || isSecondConstructorCall)) {\n      assertOnlyCalledOnce(\"Base application constructor\"); // annoying with react hot reload, disable for now}\n    }\n\n    // let appSize = appSizeFromWindowSize(\n    //   props.windowState && new Vector2(props.windowState.innerWidth, props.windowState.innerHeight)\n    // );\n    let appSize = new Vector2(800, 600);\n    this.state = {\n      appSize,\n      originalAppSize: appSize\n    }\n\n    this.app = new Pixi.Application({\n      width: this.state.appSize.x,\n      height: this.state.appSize.y,\n      antialias: true, // both about the same FPS, i get around 30 fps on 1600 x 900\n      transparent: true, // true -> better fps?? https://github.com/pixijs/pixi.js/issues/5580\n      resolution: window.devicePixelRatio || 1, // lower -> more FPS but uglier\n      // resolution: 0.5,\n      // resolution: 2,\n      autoDensity: true,\n      powerPreference: \"low-power\", // the only valid one for webgl\n      backgroundColor: 0xffffff, // immaterial - we recommend setting color in backdrop graphics\n    });\n\n    // this.RootComponent = new RootComponent({\n    //   args: {\n    //     renderer: this.app.renderer,\n    //   },\n    //   updaters: this.props.updaters,\n    //   delta: 0,\n    //   gameState: this.props.gameState,\n    //   appSize: this.state.appSize,\n    // })\n    // this.app.stage.addChild(this.RootComponent.container);\n\n    // this.renderSelf(this.props);\n\n    // // test\n    // // createBunnyExample({ parent: this.app.stage, ticker: this.app.ticker, x: this.app.screen.width / 2, y: this.app.screen.height / 2 });\n    // this.didMount();\n  }\n\n  public pause() {\n    this.app.ticker.remove(this.onTick);\n  }\n  public destroy() {\n    this.app.destroy(true, { children: true, texture: true, baseTexture: true });\n  }\n\n  public didMount() {\n    this.onTick = (delta) => this.baseGameLoop(delta);\n    this.onTick = this.onTick.bind(this);\n    this.app.ticker.add(this.onTick);\n  }\n\n  /**\n   * Please only call once!!\n   * Usage: const container = useRef<HTMLDivElement>(null); useEffect(() => { application.register(container.current!); }, []);\n   */\n  public register(curr: HTMLDivElement) {\n    curr.appendChild(this.app.view);\n  }\n\n  public update(props: Props) {\n    this.props = props;\n  }\n\n  updateSelf(props: Props) {\n    this.state.appSize = appSizeFromWindowSize(new Vector2(props.windowState.innerWidth, props.windowState.innerHeight));\n  }\n\n  // shim, called from react, possibly many times , possibly at any time, including during the baseGameLoop below\n  rerender(props: Props) {\n    console.log(\"base app rerender called\", { playerUI: props.gameState.playerUI });\n    this.props = props;\n    if (!this.RootComponent) {\n      // finish initialization\n      this.RootComponent = new RootComponent({\n        args: {\n          renderer: this.app.renderer,\n        },\n        updaters: this.props.updaters,\n        delta: 0,\n        gameState: this.props.gameState,\n        appSize: this.state.appSize,\n      })\n      this.app.stage.addChild(this.RootComponent.container);\n\n      this.renderSelf(this.props);\n\n      // test\n      // createBunnyExample({ parent: this.app.stage, ticker: this.app.ticker, x: this.app.screen.width / 2, y: this.app.screen.height / 2 });\n      this.didMount();\n    }\n  }\n\n  renderSelf(props: Props) {\n    this.app.renderer.resize(this.state.appSize.x, this.state.appSize.y);\n  }\n\n  public didUpdate(props: Props) {\n  }\n\n  baseGameLoop(delta: number) {\n    // assume props is up to date\n    this.updateSelf(this.props);\n    // send props downwards\n    this.RootComponent?.update({\n      args: {\n        renderer: this.app.renderer,\n      },\n      updaters: this.props.updaters,\n      delta,\n      gameState: this.props.gameState,\n      appSize: this.state.appSize,\n    });\n    \n    this.renderSelf(this.props);\n    this.didUpdate(this.props); // add updaters to queue if we want them for next cycle\n    this.props.args.fireBatch(); // fire enqueued game state updates, which should come back from react in the rerender()\n  }\n}\n","import { GameState, PointNodeRef } from \"../data/GameState\";\nimport { HashSet } from \"../lib/util/data_structures/hash\";\nimport { Vector2 } from \"../lib/util/geometry/vector2\";\nimport { assertOnlyCalledOnce } from \"../lib/util/misc\";\nimport { computePlayerResourceAmounts } from \"./ComputeState\";\nimport { ZLevelGenFactory } from \"./WorldGenStateFactory\";\n\nexport type GameStateConfig = any;\n\nexport class GameStateFactory {\n  public config: GameStateConfig;\n\n  constructor(config: GameStateConfig) {\n    this.config = config;\n  }\n\n  public create(seed: number | undefined | null = undefined): GameState {\n    if (seed === undefined) {\n      assertOnlyCalledOnce(\"GameStateFactory.create\");\n    }\n    const mySeed = seed || 0x19283;\n\n    const zLevel = new ZLevelGenFactory({}).create({ seed: mySeed, z: 0, startingChunks: 0 });\n    const origin = new Vector2(0, 0);\n    const firstId = zLevel.chunks.get(origin)?.pointNodes.get(origin)?.id!\n    const pointNodeRef: PointNodeRef = new PointNodeRef({\n      z: 0,\n      chunkCoord: origin,\n      pointNodeId: firstId,\n      pointNodeCoord: origin\n    });\n\n    const gameState = {\n      worldGen: {\n        seed: mySeed,\n        zLevels: { 0: zLevel },\n      },\n      playerSave: {\n        availableSp: 0,\n        // justAllocated: undefined,\n        activeQuest: undefined,\n        batchesSinceQuestStart: 0,\n        allocatedPointNodeSet: new HashSet([pointNodeRef]),\n        allocatedPointNodeHistory: [pointNodeRef],\n      },\n      playerUI: {\n        selectedPointNode: undefined,\n        activeTab: 0\n      },\n      computed: {\n      }\n    }\n    gameState.computed = { ...computePlayerResourceAmounts(gameState) };\n    return gameState;\n  }\n}","import React, { useContext, useMemo, useState } from \"react\";\nimport \"./PixiComponent.css\";\nimport { GameState, WindowState } from \"../data/GameState\";\nimport { PixiWrapperComponent } from \"./PixiWrapperComponent\";\nimport { Lazy } from \"../lib/util/misc\";\nimport { PixiReactBridge } from \"../pixi/PixiReactBridge\";\nimport { UseGameStateContext } from \"../contexts\";\nimport { GameStateFactory } from \"../game/GameStateFactory\";\nimport { batchifySetState } from \"../lib/util/batchify\";\n\nconst initialApplication = new Lazy(() => new PixiReactBridge());\n\nexport function PixiComponent(props: { originalSetGameState: Function }) {\n  // eslint-disable-next-line\n  const [_, gameStateUpdaters]  = useContext(UseGameStateContext);\n  const [windowState, setWindowState] = useState<WindowState>({\n    orientation: \"original\",\n    innerHeight: window.innerHeight,\n    innerWidth: window.innerWidth,\n  });\n  let [batchedSetWindowState, fireBatchedSetWindowState] =\n    useMemo(() => batchifySetState(setWindowState), [setWindowState]);\n\n  // needed to prevent react double-render for some reason (dev mode??)\n  const [application, setApplication] = useState(initialApplication.get());\n\n  window.onresize = () => {\n    batchedSetWindowState(old => {\n      old.innerWidth = window.innerWidth;\n      old.innerHeight = window.innerHeight;\n      return { ...old };\n    })\n  };\n\n  return (\n    <>\n      <PixiWrapperComponent application={application} windowState={windowState} fireBatchedSetWindowState={fireBatchedSetWindowState}/>\n      <button onClick={() => {\n        gameStateUpdaters.update((old) => {\n          let newGameState = new GameStateFactory({}).create(old.worldGen.seed);\n          old.playerSave = newGameState.playerSave;\n          old.playerUI = newGameState.playerUI;\n          old.worldGen = newGameState.worldGen;\n          return old\n        });\n      }}>Reset game state</button>\n      <button onClick={() => {\n        application.pause();\n        application.destroy();\n        setApplication(new PixiReactBridge(undefined, true));\n\n        let newGameState = new GameStateFactory({}).create(+new Date());\n        props.originalSetGameState((old: GameState) => {\n          old.playerSave = newGameState.playerSave;\n          old.playerUI = newGameState.playerUI;\n          old.worldGen = newGameState.worldGen;\n          return old\n        });\n      }}>Get a fresh seed, reset, and rerender</button>\n      <button\n        onClick={() => {\n          application.pause();\n          application.destroy();\n          setApplication(new PixiReactBridge(undefined, true));\n        }}\n      >\n        Rerender pixi application\n      </button>\n    </>\n  );\n}\n","import \"./QuestProgress.css\"\nimport React from \"react\";\nimport { Quest, ResourceType } from \"../data/GameState\";\nimport classnames from \"classnames\";\n\ntype Props = {\n  remainingPoints: number,\n  createQuestCb: () => void,\n  activeQuest: Quest | undefined,\n  numBatches: number,\n  playerResourceAmounts?: { [k in ResourceType]: number },\n}\nexport default function QuestProgress({\n  activeQuest,\n  remainingPoints,\n  createQuestCb,\n  numBatches,\n  playerResourceAmounts,\n}: Props) {\n\n  const isQuestComplete = activeQuest && (playerResourceAmounts?.[activeQuest.resourceType] || 0) >= activeQuest.resourceAmount;\n  const doClaimReward = () => {\n    window.alert(\"your score increased by 831!\");\n  };\n  return (\n    <>\n      {activeQuest === undefined ? (<>\n        <h2> You have no <br />active quests! </h2>\n        <br></br>\n        <br></br>\n        <button className=\"button\" onClick={() => {\n          createQuestCb();\n        }}>Get a quest</button>\n        <br></br>\n        <br></br>\n        <br></br>\n      </>) : (<>\n          <h2> Active quest: </h2>\n          <h3>Goal:</h3>\n          <div>{activeQuest.resourceAmount} {activeQuest.resourceType}</div>\n          <br></br>\n          <h3>Current:</h3>\n          <div className={classnames({ good: isQuestComplete })}>{playerResourceAmounts?.[activeQuest.resourceType]} {activeQuest.resourceType}</div>\n          <br></br>\n          <h3>Efficiency:</h3>\n          <div>{'SS'}</div>\n          { isQuestComplete ? (<>\n            <br></br>\n            <button className=\"button\" onClick={() => {\n              doClaimReward();\n            }}>\n              Claim reward\n            </button>\n          </>) : (<></>)}\n          <h3>Batches so far: </h3>\n          <div>{numBatches}</div>\n          <br></br>\n          <div>(Hint: You won't run <br />out of skill points, but<br /> they come in batches -<br />\n          try to use the <br /> fewest you can!)</div>\n        </>)}\n      <br></br>\n      <h3> Available SP: </h3>\n      <div>{remainingPoints}</div>\n      {(remainingPoints === 0) ? (<div><br></br>(Start a quest first!)</div>) : (<></>) }\n    </>\n  );\n}\n","import React from \"react\";\nimport \"./Sidebar.css\";\n\nexport default function Sidebar({ children }: any) {\n  return <div className=\"layout\">{children}</div>;\n}\n","import React from \"react\";\nexport default function TabContent({ showContent, children }: any) {\n  return <div hidden={!showContent}>{children}</div>;\n}\n","import React from \"react\";\nimport \"./Tabs.css\";\n\nexport default function Tabs({ value, labels, onChange } : any) {\n  return (\n    <div className={\"tab-label-container\"}>\n      {labels.map((label: any, i : any) => (\n        <Tab onClick={onChange} value={i} active={value === i} key={i}>\n          {label}\n        </Tab>\n      ))}\n    </div>\n  );\n}\n\nfunction Tab({ onClick, value, active, children } : any) {\n  const handleClick = () => {\n    onClick(value);\n  };\n  return (\n    <div className={active ? \"tab-label active\" : \"tab-label inactive\"}>\n      <div onClick={handleClick}>{children}</div>\n    </div>\n  );\n}\n","import React, { useEffect, useState } from \"react\";\nimport { ComputedState, PointNodeRef, ResourceType, WorldGenState } from \"../data/GameState\";\nimport { HashSet } from \"../lib/util/data_structures/hash\";\nimport { canAllocate } from \"../game/Neighbors\";\nimport { computePlayerResourceAmounts } from \"../game/ComputeState\";\n\ntype Props = {\n  selectedPointNode?: PointNodeRef\n  allocatedPointNodeSet: HashSet<PointNodeRef>,\n  worldGen: WorldGenState,\n  availableSp: number,\n  computed: ComputedState\n}\n\nexport function DebugTab({\n  selectedPointNode,\n  allocatedPointNodeSet,\n  worldGen,\n  availableSp,\n  computed\n}: Props) {\n  const [history, setHistory] = useState<PointNodeRef[]>([]);\n  useEffect(() => {\n    if (!selectedPointNode) return;\n    setHistory((history) => [...history, selectedPointNode]);\n  }, [selectedPointNode]);\n\n  if (!selectedPointNode) {\n    return (<> </>)\n  }\n  const pointNodeGen = worldGen.zLevels[selectedPointNode.z]!.chunks.get(selectedPointNode.chunkCoord)!.pointNodes.get(selectedPointNode.pointNodeCoord)!\n  const isAllocated = (allocatedPointNodeSet.contains(selectedPointNode));\n  const canBeAllocated: string = canAllocate(selectedPointNode, worldGen, allocatedPointNodeSet, availableSp);\n  let nodeDescription: string = \"Nothing (empty node)\";\n  if (pointNodeGen.resourceType !== ResourceType.Nothing) {\n    nodeDescription = `${pointNodeGen.resourceAmount} ${pointNodeGen.resourceModifier} ${pointNodeGen.resourceType}`\n  }\n  return (\n    <>\n      <h3>Player resources</h3> \n      {JSON.stringify(computed.playerResourceAmounts)}\n      <h3>Current Node</h3>\n      <div>\n        Z={selectedPointNode.z}\n      </div>\n      <div>\n        Chunk={selectedPointNode.chunkCoord.x},{selectedPointNode.chunkCoord.y}\n      </div>\n      <div>\n        Node={selectedPointNode.pointNodeCoord.x},{selectedPointNode.pointNodeCoord.y}\n      </div>\n      <br></br>\n      <div>Allocated? <br />{isAllocated ? \"yes\" : \"no\"} </div>\n      <br></br>\n      <div>Can be allocated? <br />{canBeAllocated} </div>\n      <br></br>\n      <div> Stats: </div>\n      <div> {nodeDescription} </div>\n      <h3>Previous</h3>\n      {history\n        .slice(0, -1)\n        .map((pointNodeRef: PointNodeRef, i) => {\n          return (\n            <div key={i}>\n              <div>\n                Z={pointNodeRef.z} { }\n                Chunk={pointNodeRef.chunkCoord.x},{pointNodeRef.chunkCoord.y} { }\n                Node={pointNodeRef.pointNodeCoord.x},{pointNodeRef.pointNodeCoord.y}\n              </div>\n            </div>\n          );\n        })\n        .reverse()}\n    </>\n  );\n}\n\n","import { GameState, Quest, ResourceType } from \"../data/GameState\";\nimport { UpdaterGeneratorType2 } from \"../lib/util/updaterGenerator\";\n\n\nexport function createQuest(updaters: UpdaterGeneratorType2<GameState>) {\n  updaters.playerSave.activeQuest.enqueueUpdate((prev) => {\n    return new QuestFactory({}).create();\n  });\n  updaters.playerSave.batchesSinceQuestStart.enqueueUpdate((prev) => {\n    return 1;\n  });\n  updaters.playerSave.availableSp.enqueueUpdate((prev) =>  {\n    return 5;\n  });\n}\n\n\ntype QuestFactoryConfig = { }\nexport class QuestFactory {\n  public config: QuestFactoryConfig\n\n  constructor(config: QuestFactoryConfig) {\n    this.config = config;\n  }\n\n  public create(): Quest {\n    return {\n      description: \"\",\n      resourceType: ResourceType.Mana0,\n      resourceAmount: 3000\n    };\n  }\n\n}","import \"./App.css\";\n\nimport classnames from \"classnames\";\nimport React, { useCallback, useMemo, useState } from \"react\";\nimport UAParser from \"ua-parser-js\";\nimport { NodeDetail } from \"./components/NodeDetail\";\nimport { PixiComponent } from \"./components/PixiComponent\";\nimport QuestProgress from \"./components/QuestProgress\";\nimport Sidebar from \"./components/Sidebar\";\nimport TabContent from \"./components/TabContent\";\nimport Tabs from \"./components/Tabs\";\nimport { UseGameStateContext } from \"./contexts\";\nimport { GameState } from \"./data/GameState\";\nimport { GameStateFactory } from \"./game/GameStateFactory\";\nimport { Lazy } from \"./lib/util/misc\";\nimport { updaterGenerator2 } from \"./lib/util/updaterGenerator\";\nimport { DebugTab } from \"./components/DebugTab\";\nimport { createQuest } from \"./game/QuestFactory\";\nimport { batchifySetState } from \"./lib/util/batchify\";\n\n// TODO(bowei): on mobile, for either ios or android, when in portrait locked orientation, we want to serve a landscape\n// experience - similar to a native app which is landscape locked.\n// (on mobile in already landscape orientation, and in all desktop, serve ordinary orientation.)\n// also note that android webapp supports manifest.json setting orientation, but not in the browser\n// FOR NOW - ignore this\nconst browser = new UAParser().getBrowser();\nlet forceRotate = false;\nif (\n  browser.name === \"Mobile Safari\" &&\n  window.innerWidth < window.innerHeight\n) {\n  forceRotate = true;\n}\n\nconst tabLabels = [\"Quest Progress\", \"Node Details\", \"Debug\" ];\n\nconst initialGameState: Lazy<GameState> = new Lazy(() => new GameStateFactory({}).create());\n\nfunction App() {\n  const [gameState, setGameState] = useState<GameState>(function factory() {\n    return initialGameState.get();\n  });\n\n  let [batchedSetGameState, fireBatch] = useMemo(() => batchifySetState(setGameState), [setGameState]);\n  let updaters = useMemo(() => updaterGenerator2(initialGameState.get(), batchedSetGameState), [batchedSetGameState]);\n\n  let tabViews: JSX.Element[] = []\n  tabViews[1] = useMemo(() => {\n    return (\n      <NodeDetail\n        selectedPointNode={gameState.playerUI.selectedPointNode}\n        allocatedPointNodeSet={gameState.playerSave.allocatedPointNodeSet}\n        worldGen={gameState.worldGen}\n        availableSp={gameState.playerSave.availableSp}\n      />);\n  }, [\n    gameState.playerUI.selectedPointNode,\n    gameState.playerSave.allocatedPointNodeSet,\n    gameState.worldGen,\n    gameState.playerSave.availableSp\n  ]);\n  let createQuestCb = useCallback(() => createQuest(updaters), [updaters]);\n  tabViews[0] = useMemo(() => {\n    return (\n      <QuestProgress\n        remainingPoints={gameState.playerSave.availableSp}\n        createQuestCb={createQuestCb}\n        activeQuest={gameState.playerSave.activeQuest}\n        numBatches={gameState.playerSave.batchesSinceQuestStart}\n        playerResourceAmounts={gameState.computed.playerResourceAmounts}\n      />);\n  }, [gameState.playerSave.availableSp,\n  gameState.playerSave.activeQuest,\n    createQuestCb,\n  gameState.playerSave.batchesSinceQuestStart,\n  gameState.computed.playerResourceAmounts\n  ]);\n  tabViews[2] = useMemo(() => {\n    return (\n      <DebugTab\n        selectedPointNode={gameState.playerUI.selectedPointNode}\n        allocatedPointNodeSet={gameState.playerSave.allocatedPointNodeSet}\n        worldGen={gameState.worldGen}\n        availableSp={gameState.playerSave.availableSp}\n        computed={gameState.computed}\n      />);\n  }, [\n    gameState.playerUI.selectedPointNode,\n    gameState.playerSave.allocatedPointNodeSet,\n    gameState.worldGen,\n      gameState.playerSave.availableSp,\n    gameState.computed\n  ]);\n\n\n  return (\n    <div className={classnames({ App: true, \"force-landscape\": forceRotate })}>\n      <UseGameStateContext.Provider value={[gameState, updaters, fireBatch]}>\n        <PixiComponent originalSetGameState={setGameState}/>\n        <Sidebar>\n          <Tabs\n            value={gameState.playerUI.activeTab}\n            labels={tabLabels}\n            onChange={updaters.playerUI.activeTab.getUpdater()}\n          />\n          {tabViews.map((component, i) => {\n            return (\n              <TabContent key={i} showContent={gameState.playerUI.activeTab === i}>\n                {component}\n              </TabContent>\n            );\n          })}\n        </Sidebar>\n      </UseGameStateContext.Provider>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import crypto from \"crypto\";\n\n/**\n * NOTE(bowei): we use a hash function that is NOT md5 -\n * Either https://github.com/sublee/squirrel3-python/blob/master/squirrel3.py or https://github.com/svaarala/duktape/blob/master/misc/splitmix64.c works fine and is much faster\n * Reference: https://www.youtube.com/watch?v=e4b--cyXEsM or https://www.youtube.com/watch?v=LWFzPP8ZbdU\n * TODO(bowei): port bigint to wasm for faster 64bit operations\n */\n\n// NOTE(bowei): untested\nexport function splitmix64(seed: bigint, i: bigint) {\n    let z: bigint = seed + i * BigInt(\"0x9e3779b97f4a7c15\");\n    z = ( z ^ ( z >> BigInt(30) ) ) * BigInt(\"0xBF58476D1CE4E5B9\");\n    z = ( z ^ ( z >> BigInt(27) ) ) * BigInt(0x94D049BB133111EB);\n    return z ^ ( z >> BigInt(31) );\n}\n\nexport const INTMAX32 = 2 ** 32;\nexport function squirrel3(i: number) {\n  let n = (i + INTMAX32) % INTMAX32;\n    n = Math.imul(n, 0xb5297a4d);\n    n ^= n >>> 8;\n    n += 0x68e31da4;\n    n ^= n << 8;\n    n = Math.imul(n, 0x1b56c4e9);\n    n ^= n >>> 8;\n    return (n + INTMAX32) % INTMAX32;\n}\nexport const PRIME32 = 0x3233f2cd; // not used ; useful for hashing integers; a 32 bit prime\n\n/**\n * Md5 is 16 bytes, or max int of 256 ** 16 = 2 ** 128\n */\nexport class HashState {\n  private seed!: Buffer;\n\n  /**\n   * HashState().step(\"foo\") is equivalent to HashState(\"foo\")\n   */\n  constructor(seed?: string) {\n    const buffer = crypto\n      .createHash(\"md5\")\n      .update((seed || \"\").toString())\n      .digest();\n    this.seed = buffer;\n  }\n\n  public peekRandom(): number {\n    const buffer = crypto.createHash(\"md5\").update(this.seed).digest();\n    return Number(this.bufferToBigInt(buffer) % BigInt(2 ** 32)) % 2 ** 32;\n  }\n\n  // increment the seed linearly by 1\n  public step(numSteps: number = 1) {\n    this.seed = this.bigIntToBuffer(this.bufferToBigInt(this.seed) + BigInt(1));\n  }\n\n  public stepSeed(seed: string) {\n    const buffer = crypto.createHash(\"md5\").update(seed.toString()).digest();\n    this.seed = this.bigIntToBuffer(\n      this.bufferToBigInt(this.seed) + this.bufferToBigInt(buffer)\n    );\n  }\n\n  private bigIntToBuffer(b: bigint): Buffer {\n    let buf = Buffer.alloc(16);\n    let val = b;\n    for (let i = 0; i < 16; i++) {\n      buf[i] = Number(val % BigInt(256));\n      val = val / BigInt(256);\n    }\n    return buf;\n  }\n\n  private bufferToBigInt(b: Buffer): bigint {\n    let val = BigInt(0);\n    for (let i = 0; i < 16; i++) {\n      val = val * BigInt(256) + BigInt(b[i]);\n    }\n    return val;\n  }\n\n  public random(): number {\n    this.step();\n    return this.peekRandom();\n  }\n}\n"],"sourceRoot":""}